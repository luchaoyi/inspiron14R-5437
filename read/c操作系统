<现代操作系统|V4>

进程
	windows从一开始父子进程地址空间不同，unix使用COW机制
	windows没有进程层次父子进程的概念

线程
	进程把资源集中在一起，线程是执行的实体
	一些CPU已有硬件支持多线程，允许ns内线程切换
	
	用户空间线程
		内核不知道线程存在，在不支持线程的OS上，可以实现用户空间线程
		线程切换不陷入内核效率高，线程表在用户进程中
		用户级线程可以为应用程序定制调度程序，可以更好的服务于应用程序
			
		内核不知道线程存在认为是单线程进程模型，阻塞系统调用和缺页中断会阻塞进程，阻塞进程使进程中所有线程停止
		进程内部没有时钟中断，除非线程自动放弃CPU，否则其它线程不能运行
		
	内核线程
		内核支持管理线程，线程由内核调度，当发送阻塞系统调用和缺页中断时系统可以选择进程的其它线程或其它进程的线程
		内核线程开销大于用户线程
		存在问题
			多线程进程fork
			信号，信号是发送给进程的
			
	混合实现
		一个内核线程对应多个用户线程
		
	弹出式线程
		消息到达后创建一个专门处理消息的新线程

	管程
		由编译器实现的互斥机制
		同一时刻，只有一个进程可以在管程内运行，若进程要进入管程，管程内有进程运行则进程阻塞直到管程内没有活跃进程
	调度
		每秒钟切换进程太多会大大浪费CPU时间
		进程等待外部设备完成工作而被阻塞是IO活动
		
		非抢占式没有时间片概念，进程运行直到发生IO阻塞或主动让出CPU，否则一直在运行
		抢占式时间片用完则CPU被抢占，让其它进程运行
		
		批处理系统
			FCFC 先来先服务
			SJF 最短作业优先 运行时间可预知的 	
			SRTN 最短剩余时间优先
		交互式系统
			时间片轮转调度
				短时间片引起更多抢占降低CPU效率，长时间偏使短的交互请求响应时间变长
			优先级调度
				允许优先级高的先运行，并设置时间片，时间片用完则让出CPU,并降低进程优先级
				低优先级可能会产生饥饿现象
			CTSS
				最高优先级分配一个时间片，用完后被移动到次优级，次优级有2个时间片，以此类推
				若是需要交互的程序，当终端回车键按下则立马被移动到最高优先级
			
		调度机制和调度策略分离，如优先级调度，调度机制由内核实现，但提供了设置进程优先级的接口用户可以使用它来设置调度策略
	IPC问题
		抱着资源不放互相等待会引起死锁，得不到所有资源而释放自己的资源又重新申请可能会饥饿,互相让路引起活锁
		
地址空间
	内存的抽象，每个进程都有独立的地址空间
	交换技术 内存内容换入换出到磁盘
	虚拟内存
		地址空间被切分为页，每一页是连续的地址空间，当程序引用的页没有在物理空间(虚拟页在物理内存没有对应的物理页框，对应页内容还没有载入到内存)时引发缺页中断，此时从磁盘载入数据到物理内存
		虚拟地址被送到MMU,MMU映射虚拟地址->物理地址
		
		页表
			一个虚拟地址可以被拆分为页号和偏移量，页号用于查找页表，页表记录了页的信息有
				保护位 读/写/执行权限		
				脏位M 页是否被修改
				访问位R 也被访问则置位,此位对页面淘汰算法很重要
				禁止高速缓存位
				在不在位 页是否载入物理内存
				页框号 虚拟->物理 
											
		页面置换
			最优页面置换
				不可实现的算法，无法知道页面下一次访问时间/x这是一个预测问题，采集数据预测未来x/
			最近未使用NRU
				设置R和M位，优先淘汰最近未访问已经被修改的脏页面，避免淘汰频繁访问的干净页面
			
			FIFO置换
				淘汰最老页面
			第二次机会算法
				检查最老页面R位为0，则页面又老又没用，直接淘汰
				如果R==1,再给一次机会，修改R=0，放在队列尾视为最新页面，如果在下次淘汰前被访问则R==1会再次获得重生机会,没有被访问R==0直接淘汰
			时钟算法
				和第二次机会算法一样，不过使用环形链表，避免在普通链表移动页面
				如果R==1,R=0指针前移，否则淘汰页面
	
	
			/x
			网络上传的lru的实现
				1.将最近访问的放置在链表头，每次访问某个键则此键被拉到链表头，淘汰链表尾的键,这实质上是NFU，体现最近
					->lru n多个链表，每次访问使键移动到活跃度更高的链表, 同一活跃度链表内按访问数量排序,优先删除最不活跃链表中访问次数最少的
				2.时间簇，记录键最近访问时间淘汰最老的
				3.访问累积计数并定期将计数器减半，引入遗忘，此方法就是老化算法				
			老化算法思想
				计数+遗忘
				实现遗忘的方法有很多
			淘汰键时可以引入随机性，即选择计数器最小的k个值随机淘汰			
			x/
			
			最近最少使用LRU		
				1.			
				计数器C，每条指令执行加1，当访问内存时，将当前C保存到被访问页的页表项(C相当于时间戳)，淘汰时选择C最小的页面,C越大表明在最近访问
				->C体现了最近，没有体现最少
				
				2.NFU
				每个页面都有一个计数器，每次时钟中断，检查所有页面的R值(1|0)将R只累加到计数器，计数器跟踪了页面访问次数，淘汰访问最少的
				记录页面访问次数，淘汰计数值小的
				->这里体现了最少没有体现最近
								
				老化算法	
					此算法适合硬件使用在cache中，因为所有count都要在一个时钟周期后衰减, 软件实现所有count衰减开销较大
					体现最近最少使用，则记录次数时以前的使用次数的权值应该越来越小，即应该是一个随时间衰减的累加
					老化算法计数器右移动一位，将R值累加到最高位					
						count=count>>2
						if R==1
							count+=127     /*0b1000_0000*/
						else
							count+=0
					淘汰count最小的页面
					
			工作集时钟算法
				在进程运行前预先装入工作集，预先掉页
				因为缺页中断被调入内存，请求掉页
				进程正在使用的页面集合为工作集,定义工作集是最近k次内存访问过的页面集合，优先淘汰不在工作集的页面
				
				跟踪使用次数复杂度高，近似算法从时间考虑
					工作集是过去k ms内访问过的页面
					设置定期时钟中断(k ms)清除R位，淘汰时选择R==0的即为最近k ms内未访问的
					在R==0中选择一个老页面(结合时钟FIFO算法)
					若所有R==1,则可以随机选择淘汰页面
					
					总结 定时清除R==1，以及使用时钟算法清除R==1,置换R==0的
				
			缺页中断率 计算给定时间内缺页中断数
			负载控制 内存过载，引起颠簸(频繁的缺页中断)，将一些进程周期性交换到磁盘缓解内存压力
			内存页面锁定 锁住在做IO操作的内存页面以免被移出内存
		
		
		分段
			每个段构成独立的地址空间，段可以在逻辑上将数据和程序划分到独立的地址空间利于共享和保护
			段+页
				将内存分成段，每个段看作一个虚拟内存对段分页
				根据段号找到段的页表，根据页号和偏移量定位
				虚拟地址=段号|页号|页偏移量
			x86-32
				有LDT和GDT两个表,每个程序有自己的local LDT,共享一个global GDT
				段地址->段|偏移量->线性地址
				线性地址->页目录|页面|偏移量->物理地址 
				x86-32使用两级页表，页目录10b,页表10b,一个页偏移量12b索引4KB空间,1024*1024*4KB=4GB
				当前x86的OS都没有使用段因此INTEL在x86-64中不在支持段
				
	存储管理算法
		最佳适应法
			空闲区按从小到大顺序排列，查找时从头查找，找到第一个能满足要求的，多出来的内存生成新的空闲区，如果空闲区相邻则合并
			因为是空闲区中第一个大小大于它的块，因此剩余空间一般很小，因此会产生很多小碎片
		最坏适应法
			和最佳适应法想法，从大到小搜索空闲区
		首次适应法
			空闲区按地址排列，从低地址->高地址，查找从头开始，找到第一个能满足的，多出来的内存生成新的空闲区，如果空闲区相邻则合并
			低地址部分不断地被划分,致使低地址端留下许多难以利用的很小的空闲分区
			每次查找都从低地址开始,增加了查找可用空闲分区的开销
		下次/循环适应法
			首次适应法的改进，从上次查找停止位置开始查找	
	
				
文件
	对磁盘的建模抽象，把文件看成一个地址空间
	每个文件对应一个i节点	，i节点包含文件的属性和存储数据的block地址
	几乎所有的文件系统都将文件划分为固定大小的块存储


I/O
	设备控制器上有几个寄存器或操作系统可以读写的缓冲区
	每个设备可读写位置分配一个端口号，IO端口组成IO空间独立于内存空间,使用IO指令访问(x86)
	将IO寄存器映射到内存空间(PDP-11)
	DMA
		一个硬件控制器,可以负责将磁盘设备控制器缓冲区的内容读取到内存,没有DMA时这个动作是由CPU做的
		DMA做这个事情时CPU可以干别的，此时CPU和DMA是总线的竞争者，即不可能DMA和CPU同时使用总线	
	
	磁盘臂调度
		FCFS 先来先服务
		SSF 最短寻道优先
		电梯算法 保持按一个方向移动直到那个方向没有请求为止，然后改变方向
		
		
		/*
		磁盘调度
			1.FCFS:先来先服务
			2.SSTF:最短优先寻道，即每次移动到离当前位置最近的磁道
			3.SCAN:最里--最外--最里，来回扫描寻道，中间不变方向(电梯调度)
			4.CSCAN:单方向的扫描，从里面向外面，到最外后立即从最里开始重新
			5.N步SCAN：将请求分为N个队列，不同队列按FCFS寻道
		*/
		
		
多处理机
	NUMA
		具有本地存储器和远程存储器，远程存储器访问速度慢于本地
	众核
		一致性壁垒 超大量核心数使缓存一致性变的复杂和困难可能会消耗大量的CPU资源而成为性能提升瓶颈
		已经证明适用于众核编程的模型是采用消息传递和分布式内存实现，一些芯片已经尝试放弃缓存一致性而提供硬件支持消息快速传递
		GPU是SIMD是数据并行的模型，对于任务并行并不是很适合
	调度
		多处理机调度需要决定运行哪个线程以及在哪一个cpu上运行
		智能调度 对持有自旋锁的线程设置标注，给予它更多的cpu时间,防止它被挂起后，其它等待自旋锁的进程空等待
		亲和调度 
			尽量使一个cpu在它前一次运行的cpu上运行使告诉缓存亲和力最大化
			两级调度算法
				 在线程创建时基于CPU负载将线程分配给某个CPU，即每个线程都有一个线程集合，当cpu执行完所有线程时则偷取其它cpu的线程来运行
		群调度 一组相关线程组成一个调度单位，一起调度在不同cpu上，时间片是一致的
	
	通信软件
		包的过度复制会影响性能，
			复制三次 src RAM->src接口卡 ----->recv 接口卡->recv RAM 
			复制五次 src 用户空间RAM->src内核RAM->src接口卡 ----->recv接口卡->recv内核RAM->recv用户空间RAM
		优化
			使用两个接口卡，一个供内核使用，另一个直接映射到需要的用户空间去，让用户空间RAM<->接口卡，绕过内核复制阶段,需要使用lock避免多个进程竞争
			新的网络接口卡通常有多个缓冲区，可以支持多个用户;可以使用虚拟化技术虚拟多个接口卡
			一些网络接口支持RDMA，允许一台机器直接访问另一台的内存，RDMA不需要OS的参与直接从应用的内存空间读取数据,src用户空间RAM---->recv用户空间
				
