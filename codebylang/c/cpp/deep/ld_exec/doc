分页
	比分段对内存切割的粒度更小，更充分利用了局部性，提高了内存使用率
barrier
	阻止将barrier后指令乱序交换到barrier前，即乱序不能穿透barrier
指令和数据分开的好处
	权限不同，不同保护
	使用不同缓存
	指令共享节省内存(.so)
ELF
	链接视图
		compile .c -> .o 编译器生成很多section
		link .o .o ...->.out 链接器合并同名section,ld会将rwx权限相同的section安排在一起
	执行视图
		exec .out ->进程 
			运行时os不关心section,只关心section的w,r,x权限
			为节省页面相同权限的section合并为一个segment
			segment <=> vma，运行时一个segment映射为一个vma,包含多个相同权限的页面
	section链接视图，从segment角度看是执行视图(),.o文件不需要被装载因此没有程序头(segment header)
	程序头描述了segment在文件中的位置和大小以及装载到内存中的地址和大小(描述了ELF如何被装载)
	ELF链接视图看section,运行视图看segment,连续放置在一起的section组成紧凑的segment
	PE链接视图和运行视图一致，对比ELF可视为section就是segment,PE文件编译链接中尽量产生紧凑的section,因此PE文件的section比较少
	
静态链接
		空间地址分配
			扫描所有的.o文件，收集各个section属性，长度，位置信息，相似section合并到一个section
			收集符号信息生成全局符号表
		符号解析与重定位 				
			扫描完成后各个段的虚拟地址和长度已经确定，符号在段内的相对偏移是固定的，因此可确定符号地址
			所有.o文件的的符号引用(使用内部定义的全局变量/使用其它文件定义的全局变量/调用函数)都会在重定位表生成记录
			编译.o时符号引用的指令使用一个假地址，并在重定位表中记录待修正的假指令的offset
			链接时在完成空间地址分配后所有符号的虚拟地址可以确定，这些指令可根据重定位表的记录重写地址
				绝对跳转修正 直接写绝对地址，占位的为假地址为0
				相对跳转修正 
					占位的相对跳转指令的下一条指令的地址偏移量
					A跳转到B，A后面的指令位于A+4的位置(一条指令4字节)，则addr_A - (addr_B+4) = 修正后offset
		c++ linkonece
			c++虚函数表，模板实例化代码等在不同的编译单元相同内容可能会都产生一个副本
			多个模块链接在一起时，需要消除冗余
			一般为特定内容以名称约定的方式生成一个*.linkonce.section, 链接时消除同名section仅保留一个

动态链接
	特点
		模块不合入可执行文件，不同可执行文件共享模块，节省内存
		模块兼容式更新，可执行文件不需要重新编译，扩展性强
		链接延迟到运行时，速度慢于静态(1%-5%)	
	.so的静态链接
		查找.so的符号表,若符号定义在.so中，则静态链接器将可执行文件中对应的符号标记为动态的，不进行地址重定位，留给动态链接器处理
	装载地址
		可执行文件是第一个被加载的文件，因此它可以选择一个固定的空闲地址载入
		共享库不能假设自己的载入位置，共享库可能被载入到任意位置
		可执行文件链接后可确定装载地址，.so对象最终装载地址是不确定的，在装载时根据地址空间空闲情况动态分配
	
	装载时重定位/基地址重置
		需要修改指令(见静态连接重定位)，因此不能解决多个进程指令共享问题
		普通数据段不需要共享可以使用装载时重定位，而需要共享的代码需要使用-fPIC生成地址无关代码	
		数据段在每个进程有副本，不共享，共享的是代码
		.so代码段不使用-fPIC使用基地址重置
			代码不能共享，但不通过GOT间接调用,速度快

		装载时重定位将重定位从link time延迟到load time, 可以实现任意位置装载，但装载时确定了基地址，然后根据基地址修正符号
		但是不能实现多进程共享，因为多个进程装载的虚拟基地址是不一致的
		因此.so实现指令共享需要使用-fPIC技术
		但对于数据，数据每个进程是私有的，且.so中定义的数据也会在数据段产生副本，所有访问会指向副本
		因此对于数据符号使用装载时重定位(可执行映像内部的代码和数据和外部数据副本装载在固定位置), 对于动态库模块实现代码共享使用-fPIC

				
	地址无关代码 -fPIC (GOT存储指针，间接访问)
			1.模块内部函数调用
				使用相对偏移调用 call(E8)，调用位置相对于被调用位置offset不变，因此不需要重定位
				全局符号介入
			2.模块内部数据访问
				指令与访问的数据相对偏移固定
				数据地址 = 当前指令地址+相对offset
			3.模块间数据访问-GOT间接访问
				GOT在模块内通过方法2得到变量在GOT
				GOT存储了变量的地址(此地址是ld在动态链接时填入的)，通过GOT间接访问
			4.模块间函数调用
				如3通过GOT表项间接调用
				模块间的数据访问和函数调用 => 方法2找GOT通过GOT间接寻址
				GOT表项由ld在动态链接时填写
				
			static修饰的全局变量
					可见性从定义之处开始到文件结尾
					不会被其他文件所访问，修改，即不能extern
					其他文件中可以使用相同名字的变量，不会发生冲突
			全局变量
					不能区分extern的全局变量是否为同一个模块
					可执行文件不会使用PIC机制
					=>	
					静态链接器会在可执行文件.bss段创建全局变量的副本，其它所有使用这个变量的指令都指向ELF副本
					编译.so编译时对于定义在.so内部的全局变量当作其它模块的全局变量，使用方法3访问
					主程序有副本则GOT指向副本位置，没有副本在GOT指向.so内部变量位置
					=>
					.so中的全局变量对于不同进程不是共享的，每个进程都是在数据段有私有副本
					代码是进程共享的

		.so的数据段
			数据段不共享，每个进程私有副本，因此不担心改变
			使用装载时重定位
			
		plt延迟绑定
			非延迟绑定由ld动态链接时填写got表，延迟绑定在第一次函数用到时调用ld提供的API来填got表，绑定函数地址
			bar的调用
				首次
					GOT地址不是bar的地址，需要填表
					bar.plt ->压入bar相关信息，调用ld提供的符号解析和重定位的函数->填地址到GOT
					->GOT间接调用bar()
				下次
					bar@GOT->GOT间接调用bar()	

/*
由于进行系统调用时，操作系统要由用户态切换到内核态，而这一操作是非常浪费时间的操作，无论采用早期的int 0x80/iret中断，还是sysenter/sysexit指令，再到syscall/sysexit指令。另一方面，某些系统调用并不会向内核提交参数，而仅仅只是从内核里请求读取某个数据，例如gettimeofday()，内核在处理这部分系统调用时可以把系统当前时间写在一个固定的位置，而应用程序直接从该位置简单读取即可，无需发起系统调用。内核与用户态程序之间进行数据交互的方法就是mmap。但由于vsyscall采用固定地址映射的方式，所以存在一定的安全隐患，这一方式便被vdso所改进，vdso的随机映射在一定程度上缓解了安全威胁。虽然有了vdso，但从历史兼容性上来讲，vsyscall不能就此完全抛弃，否则将导致一些陈旧的（特别是静态连接的）应用程序无法执行，因此现在在我的3.19内核上，将同时看到vdso和vsyscal。vvar也就是存放数据的地方了，那么用户可以通过调用vdso里的函数，使用vvar里的数据，来获得自己想要的信息。而且地址是随机的，更安全
*/					
-----------<附录>----------
ELF文件 
	ELF头
	程序头
		记录segment信息,一个segment包含一个到多个section
		segment类型，在文件中的偏移和大小和在内存中的虚拟地址和大小以及r,w，权限		
	节
		.bss 
			只在段表记录大小，在符号表记录符号，不占用磁盘空间，只占用内存空间
		节头和程序头是目录，节是存储信息的位置
		字符串节
			包含了节区名和符号名(变量名/函数名等)，文件中对字符串的引用位置会存放指向此节的索引
			动态，调试等不同类型的section都会生成自己的符号节和字符串节
		符号节
			包含了符号和符号关联的信息
			符号的名(指向字符串节的索引),类型(节，函数，对象)和绑定属性(局部，全局，弱符号or弱引用)，值,大小等
			符号修饰
				unix下c语言为防止符号名和以前存在的汇编库冲突，因此编译后在符号名前添加了_(限制Linux下GCC默认不再添加_),c++语言进一步设计了namespace机制
				c++根据命名空间,参数,返回值等信息生成新的符号名用以支持函数重载,c++filt _ZN2B0C1Ev -> B0::B0(),c++filt可以解析修饰过的名字 
		.rela.*
			某节的重定位节，包含重定位信息
			.rela.plt，对位于.got和数据段的数据引用的修正(例如，指针引用了一个地址是绝对地址，指针是变量因此保存在数据段，引用的地址需要修改)
			.rela.dyn，对位于.got.plt的函数引用的修正
		.dynamic
			节头记录了所有节的信息，此节记录了动态链接相关的信息和动态链接相关的节(符号，字符串，hash,plt,got,重定位等)的信息(地址和大小)
			查找动态链接的信息
				程序头->节头->.dynamic->动态链接相关节
		.got
			外部变量的got记录
		.got.plt 
			外部函数的got记录
		.plt
			延迟绑定plt跳转代码
		.init,.fini 初始化和结束代码存放节		
	节头
		记录section信息
		节名字,类型，大小，文件中的偏移，加载到内存中的虚拟地址，权限flag
		根据不同的节类型，link个info字段还附加了此节需要的辅助信息,such as 符号头记录自己关联的字符串头的索引,重定头记录重定位所适用的节的头的索引	
～--------------------------------------
