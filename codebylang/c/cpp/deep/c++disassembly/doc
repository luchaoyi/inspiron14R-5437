对象作为返回值 
	调用方产生临时对象空间，被调用函数将局部对象复制到临时对象后栈销毁，局部对象不存在
	Call() {
		Object a;
		a = ReturnFunc();
	}
	ReturnFunc {
		Object b;
		return b;
	}
	ReturnFunc局部对象b -> 临时对象 -> Call局部对象a，非优化的情况下产生两次复制
	
虚函数	
	编译器合成vtbl，并为类添加成员vptr，编译器生成vptr，因此它需要保证初始化和复制时vptr的正确设置,因此含有vptr的类，编译器需要合成默认的构造函数和copy构造函数
	间接调用vtbl是为了构成多态，当使用指针或引用调用虚函数时(对象类属是明确的)，代码优化为直接调用不需要多态
	父类构造函数设置vptr为父类的vtbl,在此作用域调用的虚函数为父类函数，子类构造时设置vptr为自己的vtbl,同理对象析构时首先设置vptr为自己对应的vtbl,然后调用virtual的析构函数
	虚函数在vtbl中的索引按照声明顺序排列，子类vtbl中先按同样的顺序安排继承自父类的虚函数，然后自己的虚函数按声明顺序安排
	class Object{
	virtual f0();             vtbl = [&f0,&f1]
	virtual f1();
	}
	class Sub : Object{
 	virtual f1();         vtbl = [&type_info|&Object::f0,&f1,&f2,&f3],此时&f1 is &Sub::f1(),子类函数重写了自己vtbl的对应位置
	virtual f2();          
	virtual f3();
	}	
   重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同，调用时根据函数的参数来区别不同函数
   覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数一样，函数的实现体不一样
   隐藏是指派生类中的函数把基类中所有相同名字的函数屏蔽掉
   父类指针持有子类对象
   		父类中有的属性和方法，子类重写，则调用的是子类重写的属性和方法
   		父类中没有的属性和方法，此时为父类指针，调用出错，被编译器禁止
   		父类有的属性和方法，子类没有重写，则调用的为继承自父类定义的属性和方法
   		Object *p = new Sub; Object *p，不能调用p->f3()，编译会失败提示Object没有f3()，即父类指针指向子类对象，编译器禁止访问没有在父类中定义的函数和成员，因此此时vtbl虽然包含f3但是编译器在编译阶段禁止。
   		本质上定义Object *p，则对象(*p)类型为Object而不是Sub,因此它只能使用Object有的属性和方法，因此 p->f3()编译器时提示Object对象没有f3的方法,而p->f0()调用了Sub定义的版本是虚函数表对应位置被子类替换	
   		因此p允许调用f0,f1,编译禁止调用f2,f3，但此时vtbl包含所有virtual函数,调用f1时由于f1的地址被替换为子类自己的f1，因此 Object *p依然调用了子类的f1.
   普通成员方法有一个隐藏参数为this指针，因此必须有对象才能调用，而static方法，属于类所有，对象共享可以直接类::f()调用
   多重继承
   		多个父类按照继承顺序安排内存排布，每个父类对应的区域都有一个vptr和vtbl
   		vtbl记录了对应父类和子类的虚函数，不包含另一个父类的虚函数
   		class sofabed:sofa,bed
   		sofa *ptr = new sopfabed, sopa * ptr索引的为sofa对应的区域，此区域的vpter->vtbl中含有的为sofa的虚函数和sofabed添加的虚函数，不包含继承自bed的虚函数，即sofabed is a sofa,在需要sofa*的接口，只呈现sofa的特性，而不需要呈现bed的特性
