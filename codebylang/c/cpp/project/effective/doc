#Effective C++ 
virtual 
	若一个class不被意图继承或不为多态设计，则不应该有虚函数，多余生成vptr -> vtbl
	若意图为base class且为多态设计，则必有virtual 析构函数,析构函数保证是多态的,保证被基类指针/引用持有时能正确虚构
	new某种类是明确的，构造函数不需要声明为virtual函数	
	构造/析构函数禁止调用virtual函数,析构函数不吐出异常
operator= 自我赋值处理 证同测试/copy and swap
RAII 以对象管理资源，以智能指针管理对象
资源管理类的copying定义
	禁止复制
	引用计数
	转移控制
	复制资源
设计class如设计type
	构造/析构 
	pass by value 
	合法值/OP
	类型转换
pImpl模式 
	嵌入指向其它类指针，不直接嵌入其它类对象
	编译友好，移动语义友好
延后定义变量直到非用不可
异常安全 要么执行成功，要么回到执行前
inline 和 template 会导致代码膨胀	
	inline 直接插入代码到调用位置
	template 可能生成多个不同的，考虑将与templates参数无关的代码抽离模板
编译依存降低 
	前置声明+pImpl模式
	声明和定义分离到不同文件，程序依赖于声明式(接口)，不依赖实现
	virtual abstract接口类和实现类，解开接口和实现的耦合，实现变化不影响接口，但是virtual 影响了效率
继承
	public 继承是 is a 的关系
	虚函数替代方法
		NVI手法 虚函数永远是private的，设计一个非virtual的public调用private虚函数
		Strategy 设计模型，std::function手法是此模式的一种表现手法
	复合塑造 has a关系
	private继承是根据base实现出的关系
templates是编译期的多态，type被参数化，成为了duck type的感觉  

#More Effective C++
不要对数组使用多态(可参考深度解析c++对象模型，对象数组的析构)
一个输出参数的构造函数，注意使用explicit的必要性* 
为效率尽量用前缀++
new 
	new = operator new + placement new 	
构造函数防止资源泄漏
	C++拒绝为没有完成构造操作的对象调用析构函数
	构造函数由异常时需要自己注意异常处理和资源释放
	不允许异常传递到析构函数外面,保证异常函数完全执行，不被打断
懒惰计算法 
	最佳的计算就是根本不计算
	推迟计算到必须和变量定义到必须时
multiple dispatch	作用在多个对象上的虚函数，行为取决于多个对象的动态类型而不是一个，虚函数机制只取决于一个对象
	虚函数+RTTI 虚函数机制决定一个类型行为，RTTI的if-else判断其它对象...  可维护性差
	虚函数+重载
	虚函数+模拟虚函数表
	访问者模式
抛异常/自己给自己赋值/在没有赋初值前就使用对象/给对象赋了值而没有使用/会赋过大的值、过小的值或空值
extern 'C' 禁止C++的名变换，extern 'C'简化了维护那些必须同时供 C++和 C 使用的头文件的工作
指针比较
	编译器会自动调整使指向同一个对象的基类指针和子类指针的==为true
	地址比较时将指针转为void*，比较地址
