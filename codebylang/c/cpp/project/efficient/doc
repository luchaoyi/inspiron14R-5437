性能要点
	语言结构 src->汇编
	体系结构 内存/缓存/core
	库
	编译器优化 src->汇编

构造&析构
	继承与复合为了代码重用，但打击了性能，应关注OO机制额外添加的指令和有效逻辑指令的比例
	#构建Lock对象，实现int变量递增是绝对没必要的，实现复杂的数据库操作逻辑可能是有必要的
	如果没有到复杂类型的更多功能，则选择基本类型更好 #string -> char*,vector -> int[]
	推迟定义，避免像c语言都在开头构造

虚函数
	一般时运行时解析的，因此虚函数无法内联，内联是编译期间解析的*
	频繁调用的简单虚函数，性能损失最大，简单函数是inline的受益者
	考虑模板编译时多态，代替运行时多态*
	理论上对象确定的虚方法调用可以内联，取决于编译器实现
		X x;#x确定是X的实例
		X *xptr = new X; #假设xptr在下文没有其它赋值，则持有的对象类型是确定的
		
返回值优化
	局部对象返回值 -> 临时对象 -> 接收对象，优化直接用临时对象代替局部对象
	多个return 返回不同名词对象 / 复杂函数不会执行返回值优化
	没有RVO时可使用计算性构造函数思想*
	explicit可拒绝将构造函数作为类型转换*
	避免临时对象，使用&和指针
	尾递归优化 尾部递归，递归完即返回，可转为循环或不保存函数栈
	
内联
	#cpp使用const/constexpr和inline以及template来代替宏
	函数调用开销
		栈push/pop
		call和return跳转流水线
		返回或传递对象复制开销	
		编译器不擅长或无法跨越函数边界优化，内联展开后编译器可进一步优化*
	#不确定性(信息量不足)阻碍编译器优化，为编译器提供更多信息，减少不确定性，可使代码性能更好,如const...	
	指令数不能说明一切，因为不同指令消耗时间不同*
	精简的方法和唯一化方法(只在一个位置被调用过)总可以inline
	
优化
	延迟计算直到用到
	优先使用库，必须时做牺牲灵活性的替换
	if 短路运算
	switch 跳转表
	loop展开，重复外提		
	尾递归优化
	查找表
	常用位运算
		mod 对x是2的n次方，则%x，转换为&(x-1)
		汉明称重 二进制1的个数
		正数变成负数，负数变成正数
			~a + 1 # 正数取反加1为对应的负数(补码表示)，负数取反加一，为其正数原码
		xor
			1.交换律  a ^ b ^ c = a ^ c ^ b
			2.结合律  (a^b)^c == a^(b^c)
			3.x^x=0，x ^ 0 = x
			4.自反性  xor的逆运算为xor，+/-为逆运算因此,a == a+b-b,同样a = a ^ b ^ b           
			swap利用逆运算
				a:=a + b;
 				b:=a - b;
 				a:=a - b;
 				-  
				a ^= b; #a=a^b,but if a==b,a^b is 0*
				b ^= a; #b=a^b^b = a 
				a ^= b;  #a=a^b^a =b
			数组某个元素只出现一次以外，其余每个元素均出现两次，根据性质1,2,3可得将数组所有元素异或最终可找出不一样的数

*内存池技术
	默认的new和delete是调用malloc/free并构造析构的通用的保证线程安全的内存申请，若知道应用场景则可以针对性的专用优化
	固定大小 可变大小
单线程
多线程
