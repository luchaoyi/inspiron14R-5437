模板化的 = 和构造函数
	不被认为是copy构造函数和copy赋值运算符，因为这两个函数参数要求相同类型
	模板不会隐藏默认的copy构造函数和copy赋值运算符，类型相同时使用默认的模板不会实例化
	类型不同时实例化，但产生的不是copy构造函数和copy赋值运算符
	注意，一旦定义了任意构造函数，编译器将不在提供缺省的
	使用一个普通的函数在 = 和 copy间共享代码
	
异常
	资源泄漏
		异常打断了正常控制流，使程序包含了很多隐藏路径
		一般构造函数会抛出异常，以指示构造失败
		析构函数不要抛出异常,一般声明析构函数的class需要释放资源，异常可能打断了完整析构过程，导致资源的不完全释放
		建议使用RAII管理资源，资源释放不依赖特定流程，只依赖作用域，异常打断流程但离开作用域会保证资源释放
	强异常安全
		commit-or-roolback
		异常出现不能包含副作用
	基本异常安全
		异常发生产生副作用但不产生资源泄漏
			
class
	对象的A++性能差于++A,因为需要先保存旧值后自增，会产生临时对象
	成员模板构造函数不是拷贝构造函数
	尽量避免值传递的函数调用
	虚函数
		虚函数是通过指针动态调用函数
		g++默认禁止构造函数为虚函数，因为没必要
			new对象是确切的不需要多态
			对象构造时行为vptr->vtbl
		非基类函数析构函数没必要为虚函数，影响效率，但基类必须为virtual
	覆盖与隐藏
		隐藏
			静态行为，当子类定义了与父类的同名函数，对父类同名函数的调用都会被编译器禁止，隐藏了父类同名函数
			隐藏禁止静态行为，但被隐藏的函数为虚函数时，通过虚表的动态调用是不被禁止的
			using可引入被隐藏的函数，隐藏是静态行为，取决于编译器是否允许
		覆盖 子类重写了父类的函数(同名，同参数)
	op= 和 op
		a op= b 比 a = a op b 有效率,因为op = 直接作用于a,返回a的引用，而a op b 返回临时对象并引发拷贝给a
		提供op和op=，op调用op=产生
	继承
		x public y 
			界面继承 x is y
			建议仅用public继承建模x is y // 必须使用运行时多态，不滥用
		x private y 
			实现继承，根据y实现出x
			可替换为y is x的member实现
		*不要为了复用代码而使用public继承，也尽量优先 使用复合/pimpl/模板policy class 而非private继承，严格审视继承关系，避免继承体系爆炸
		继承是class与class关系最强的一种，优先考虑class之间的更弱的交互关系
	class  is 数据 + 操作函数，操作函数是成员函数/同期(相同namespace/文件)提供的普通函数

编译依赖
	pimpl 隔离实现和调用，构建编译防火墙
		一个类被分裂为对外public接口和对内实现两个类
		暴露给用户的可见类，用户需要#include
		实现的细节(私有部分)封装在私有的pimpl，实现的修改不影响用户的调用，不需要重新编译
		一次个对象被分裂为了两部分，pimpl需要反向访问对象时需要一次反向指针self_
	性能代价
		完整的对象一次内存分配，分裂为两次，而且一次必为new/malloc开销大,非常必要时才需要重载new来实现高效的固定尺寸内存分配
		访问变为间接

接口原则 
	类X的接口为X的成员函数或提到X的普通函数，提到X的普通函数在名字搜索时打开了X的namespace
	成员函数的关联性更强，普通函数可能需要借助friend来获取更多权限

指针
	不要以多态处理数组 
	new[] 配 delete [],将指向数组的指针传递给delete[]的行为是难以语料的
	
智能指针所有权
	unique_ptr
		只能独占所有权，可显式转交给别人，支持引用传递
		不支持拷贝语义
	shared_ptr & weak_ptr
		共享所有权，引用计数
		支持拷贝语义
		weak_ptr
			用于探测shared_ptr的状态，没有指针功能，可使用lock获取一个shared_ptr
			解决shared_ptr循环引用问题
			
证同与自赋值的必要性？
	if (this == &rhs) retrun *this
	
隐式转换 
	单参数构造函数也是一个隐式类型转换符
	explicit关键字仅用于修饰仅有一个参数的类构造函数，让编译器禁止发生隐式类型转换
	int i;
	A a;
	a=i;int值赋值给类型A的变量，若存在A A(int)则发生了隐式类型转换，explicit会禁止这个行为=>因此仅可以a=A(i)
	
其它	
	const 
		对内建类型值传递和返回声明const是不必要的，没有什么好处
		使用const_cast转型去掉const特性是不推荐的，考虑对象内部使用mutable
	inline
		内联暴露了细节，而且需要重编译调用函数
		不用滥用内联，让性能分析器告诉你内联，程序员的判断可能不准*
	assert
		不要再assert中加入有副作用的代码，否则导致debug和release模式行为不一致
	执行顺序
		不依赖标准未明确的表达式求值顺序
		各文件的全局变量和类静态变量初始化顺序没有定义
		
