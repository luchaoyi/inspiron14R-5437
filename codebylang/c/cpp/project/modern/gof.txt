/*
OOP 类型绑定操作，不同类型的公有代码如何复用
	继承/组合，继承是一种紧耦合，而持有对象或持有对象的指针是一种松耦合
	AOP 装饰器 
	STL泛型算法，容器提供Iterator,公有行为抽象为泛型算法可作用于多种容器
STL的设计模式
	配接器/装饰器
	迭代器
	骨架模式，可配置policy类, functor callback
面向抽象编程
	抽象是描述共性，将不同点分离出去，待具体实现
	转发，委托，间接性，中间层，解耦合
	间接性，中间层引入隔离利于减少编译时间
求同存异抽象法
	相同点抽象到一个类，不同点独立出去，抽象类引用变化的部分
*/
模式是 特定环境下，问题，解决方案 的关系
体系结构模式
	层
		分层抽象,子任务分解到不同层次(TCP/IP)
	管道和过滤器
		处理数据流，数据流通过管道，经过过滤器组件转换.(类似流水线结构)
	黑板
		多个专家工作在一个公共数据集上,都可以rw,某个时刻谁操作由仲裁决定.
	代理
		构建分布式系统，代理者负责通信
	微核
		最小化核心和扩展并和客户分离(os)
	映像
		元层次包含自描述信息，改变信息会改变构建在元层次上的基本层逻辑
		
类继承&接口继承
	类继承 根据一个对象的实现描述了另一个对象的实现，代码共享
	接口继承 描述了一个对象什么时候可以被另一个对象代替
	针对接口编程
继承&组合
	继承破坏了封装性，父类变化导致子类变化
	代码继承优先使用组合，一个窗口拥有一个矩形，而不是一个窗口有一个矩形
	继承更多的用于定义接口，即封装公共接口，代码复用倾向使用组合
工具箱
	一组基础可复用类的集合，utility系列
框架
	面向领域，强调复用性
	如何在框架下编程是定死的，约束了代码的自由编写，反向控制IOC

创建型模式
	抽象实例化过程,系统仅知道抽象类定义的接口，具体类who,when,where,what被创建很灵活
	类创建模式使用继承改变被实例化的类，对象创建模式将实例化委托给另一个对象
	
	抽象工厂 
		封装一系列产品的生成，一个工厂就是一个系列产品的集合
		使用不同工厂，可容易整体替换一系列产品(如windows GUI ->linux GUI)
		*缺点:如果要增加一个新产品，则所有工厂都要改动,即使用不同集合简单，为集合添加元素复杂
		关联模式
			抽象工厂类 通常使用工厂方法 / 原型实现，一般为单例
	工厂方法
		框架使用抽象类维护类的关系,类A所在抽象层次，A仅知道如何使用B(交换关系)，但不知道类B的细节，无法创建B，但是却需要创建B
		A声明一个接口来代替具体创建B的过程，以保证流程继续推进，此接口为工厂方法,接口的实现被推迟到A的子类中
		即将关联类B的实例化的过程推迟到子类C，子类C实现时得知B的一个具体子类则可完成实例化 #骨架在父类已经定			
		#将一切变化、未知和依赖独立出去，保证完成最高抽象流程
		HOOK 效果
			A为子类提供了HOOK机制
		A的子类可以使用模板代替
	生成器*
		复杂对象由多个组件装配而成，装配过程不变，Director为装配过程 	#构造过程是骨架
		各个组件Builder可以变换，组件变换后导致同样的装配过程但产生了不同的产品
		构造过程和表示(具体组件)分离,可改变产品的内部表示
		Director 控制下的精细构造
		例子
			产品 饮料
			Director 液体 + 固体 
					 水 + 柠檬 -> 柠檬汁
					 牛奶 + 冰淇淋 ->雪顶 
					 水 + NULL ->纯净水
			编译子系统语法分析*
				产品 语法分析树
				Director is Parser一个语法结构，调用Builder构造Ast
	原型
		clone(对象)生成对象, 可大大减少类的数目，原型语言 all is 对象
		C++静态语言中类不是对象，且运行时刻类型信息很少，因此原型很有用
		通过注册原型生成对象，避免类型爆炸
		原型管理器 一个注册关联表，注册管理原型对象
	单例
		自己创建自己，禁止其它创建，全局变量的一种改进
		可以控制类生成对象的数目，lazy init 直到使用时才构造
		可以使用单件注册表注册实例
		#多线程下的单例

结构型模式
	Wrapper
		适配器
			接口转换，复用已有类
		装饰器/AOP
			类嵌入，保持接口不变性，装饰器添加新功能，原功能委托给嵌入类;动态，透明地添加功能，扩展已有类
			适合小对象，包装特别复杂对象，要保持接口不变性，代价太高
			复杂对象适合策略模型将行为转发给策略对象，而不是委托给嵌入对象
										 -----                     -----
			装饰对象和被装饰对象有相同的接口，因此可以继承自同一个Base类
	桥接/pImp*
		抽象与实现分离，可独立变化
		抽象类针对接口，专心于管理类的关系和交互，imp类具体实现,	抽象部分将请求转发给imp类, 抽象类和imp类没有继承关系，是协作关系*
		抽象部分与实现部分是协作关系，不是上下级关系，因此可以独立变化 #有点业务外包的感觉
		优势
			有助于分层，编译友好，隐藏实现细节，移动语义友好(C++)
	组合
		#组合不是聚合
		部分-整体，部分和整体都是同一个抽象类的子类		#Ast结构
		递归组合，层次结构，部分和整体对外有一致抽象
		抽象类需要最大化接口
	外观模式
		#中间层，解决一切
		划分子系统，减少系子系统之间的通信和依赖，子系统和客户类产生多对多混乱关系时，加入一个抽象层，隔离上下，解耦合
		隔离减少编译依赖性，优化编译时间*
	共享对象
		文档每一个字符创建一个对象 ->26个字母创建对象并共享，文档索引共享对象
		极大节省内存
		共享对象管理，垃圾回收
	代理*
		代理控制对对象的访问，不直接访问原对象(不方便直接访问原对象)
		远程代理 
			被访问对象位于不同地址空间，本地提供一个代理负责通信
		虚代理 
			需要时才创建开销很大的原对象并初始化
		保护代理
			控制访问权限，保护原始对象
		智能指针
			取代简单指针，提供附加操作
行为模式
	#封装变化，将变化的特征独立封装一个对象
	职责链 
		解耦合 请求发送者和处理者，将处理者串联为一个链，请求按照链式传递(总线模型)
		处理者要么处理，要么转发next,前面的具有更改优先级，可提供机制动态注册Handler到链中
		例子 窗口事件响应
	观察者/发布订阅模式
		建立一对多的依赖关系，一个对象状态的改变所有依赖对象被通知
		目标有状态并提供接口可以注册观察者，发生变更时通知观察者
		多对多映射可以考虑引入一个 中介 更改管理器
	解释器模式
		特定类型问题发生频繁足够高则可以定义DSL
		终结符可定义为共享对象
	迭代器/游标
		提供访问聚合对象内元素的方法，并不暴露细节
		定义空迭代器处理边界条件*
	中介模式
		对象直接互相交互，引入中介对象解耦合，多对多变为集中中控
	备忘录对象
	有状态对象*
		#状态机,状态转换
		对象有状态，外在表现依赖于状态，不同状态下对请求的响应表现不同，状态的改变似乎更改了类的效果
		例子 TCP connect对象
		状态对象可以被共享以节省内存(享元模式)
	策略
		一系列算法被封装的可替换，即完成同样事情的一组策略
		当一组关联的不同类仅行为不同时，将行为独立出去 		#求同存异
		一个算法的不同变体
		例子 排流水，是一组策略，不同模式下选择不同策略
	骨架方法
		在父类完成算法的不变部分(骨架方法)，可变部分延迟到子类实现
		可以是callback机制代替
	命令/动作/事物
		请求执行命令的者 和 接受命令执行动作者 不直接耦合关联 -> 添加中间层   调用者 -> command -> 接收者
		请求者 调用命令对象来表达要做什么,命令对象和执行者关联，调用执行
		命令/动作被对象化后可扩展支持事物语义
	访问者visitor 
		visitor定义如何访问对象，不同的对象定义不同的vistor或在vistor内重载定义不同的访问方法
		被访问者开发一个accept访问，接受一个vistor,则accept内部将自身传递给vistor的访问方法
