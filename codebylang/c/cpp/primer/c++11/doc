断言
	assert 运行时，通过在定义NDEBUG宏范围将assert define为无效语句，可以仅在DEBUG下assert
	static_assert 编译时
	
虚函数
	final 表示后续子类不能被重写
	override 表示此函数是父类的重写 

构造函数
	继承&构造函数
		子类不继承父类的构造方法,使用using声明继承父类构造函数
		子类没有定义构造方法，编译器需要时调用父类的无参构造方法
		子类定义了构造函数，没有显式调用父类构造函数，则编译器需要时调用父类无参构造函数;
		若父类只定义了有参构造函数，此时编译器不合成无参构造函数，编译器不能找到父类的无参构造函数，此时需显式调用父类构造函数
	using*
		基类定一个多个同名函数(重载),子类定义了同名函数,基函数被隐藏，使用using可将父类函数引入子类作用域
		可用于引入基类构造函数，当基类有多个构造函数时，可使用using,避免一对一透传
		*基类构造函数有默认值时，using会产生多个版本的构造函数，请谨慎使用	
	委托构造
		同一个class的构造函数多个,在初始化列表位置委托其它函数帮助构造
	移动与拷贝构造
		当自定义了copy构造函数，析构函数，operator=的任何一个时，则编译器不会合成默认的移动构造函数/赋值函数
		当需要资源管理时才会定义这些函数而不是让编译器默认合成，默认合成的是浅拷贝，不能对管理资源深拷贝
		类的设计者应知道使用move还是copy，使用delete明确禁止需要禁止的构造函数
		#一个原则建议,定义了析构函数的class，要么删除copy构造函数和op=，要么实现它*
		
移动语义*
	移为己用
	左值和右值的区别 左值&地址合法
	右值
		纯右值 不和标识符关联的值
		将亡值 右值引用的临时对象
			T r = ReturnValue(); 局部变量返回值->临时对象 ->r 发生拷贝构造，临时对象和局部变量被析构
			T &/* r = ReturnValue(); r持有的为局部变量，函数返回局部变量被析构 error
			T && r = ReturnValue(); r持有临时对象，临时对象为一个将亡值，生命被r接续
	右值引用 
			实现移动语义和完美转发，避免了右值(临时对象)的不必要拷贝引发的性能问题
			左值引用，引用左值;右值引用，引用右值;const 引用，引用左右值，非const&不能引用右值，右值引用不能引用左值
			左值
				可获取地址的表达式，能出现在赋值语句的左边，对其赋值
				const修饰&,可以取地址，不能更改值
			右值 
				无法获取地址的对象，一般是临时对象
				常量值、函数返回值、Lambda表达式等
				右值被右值引用引用则可以更改右值，右值生命周期和右值引用一样长，引用关联右值后，右值被存储到特定位置可以对右值引用取地址，获得临时对象的存储地址
				右值引用可赋值给左值引用
				×××右值引用是一个左值×××，可对右值引用取内存地址*
			复制走左值引用，移动走右值引用，左右引用实现了移动语义和复制语义的分支，复制是拷贝，移动是移走
			完美转发
				std::move统一返回右值引用
				std::forward，右值返回右值引用，有条件的返回右值，主要用于模板,std::forward<T>,T由模板类型推断
				move和forward运用的都是引用折叠和类型推导的规则，使用static_cast实现的，不产生任何汇编代码，不是运行时的概念
				

	移动构造函数的合成
		没有定义析构\拷贝\op=  且 类的非静态数据成员都可以移动(有移动构造或可以合成移动构造) 编译器才可以默认合成
		自定义了和移动则拷贝被默认删除，需要显式自定义
		
	异常
		移动操作，通常窃取资源而不分配资源，因此不抛出异常
		不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept，某些STL容器仅对noexcept移动，否则执行拷贝

列表初始化
	{}在c只能初始化数组，c++11引入了std::initializer_list<T>类型
	编译器遇到{}初始化列表会生成initializer_list<T>对象，编译器会推导T的类型，当{}中元素类型不一致时会有warning,当类实现了以initializer_list<T>为参数的构造函数时则可以使用{}初始化
		
pod类型
	字节赋值
	C兼容
	静态初始化安全
	
变长...
	变长宏__VA_ARGS__,宏可以传递类型，但__VA_ARGS__不能
	变长函数 不能传递类型
	变长模板 typename... E
		E是模板参数包，模板参数包展开的方式是模板递归，引入sizeof...可以获得参数包参数的数量

线程
	原子类型
		编译器保证原子类型在不同线程间互斥访问
		atomic<T> atomic类型删除了移动和拷贝
	threa_local 
		每个线程都有一份独有的拷贝
					
类型推导*
	类型推导增强了泛型表达能力，泛型+类型推导+<type_traits>，type_traits可获得类型以及相关的特性,泛型编程是动态类型的
	auto
		推导规则类似模板参数推导规则
		当不声明为指针或引用时，auto 的推导结果和初始化表达式抛弃引用和 cv 限定符后类型一致。
		当声明为指针或引用时，auto 的推导结果将保持初始化表达式的 cv 属性。

​		auto 值推导会产生副本
​		auto& 左值引用

​		const auto& 只读引用

​		auto&& 完美引用，只读对象会推导出const auto& ，否则为非const左值/右值引用

​	decltype 
​		类型推导，获得表达式的类型
​		一般和using/typedef等联合使用		
​		不继承const volatile限定符号
​	auto+decltype可追踪模板函数的返回类型

```

			template <typename Builder>
			auto makeAndProcessObject (const Builder& builder) -> decltype( builder.makeObject() )
			{
				auto val = builder.makeObject();
				// do stuff with val
				return val;
			}

```

​	泛型
​		鸭子类型(c++模板)
​			行为是鸭子的对象被认为是鸭子，没有限定类型的概念，只关心值以及它的行为	
​		非鸭子类型(c++非模板)
​			值首先被赋予了类型为鸭子，则值的行为由类型限定，关注类型匹配
​			
enum 
​	enum E{G,L,H}; / enum {G,L,H} 
​		继承自c语言的枚举，没有作用域的概念
​		进行数值运算时被隐式转换为int,不同类型的枚举可以互相比较而不报错
​		类中的enum可作为一个staic int的用法，E e; E是类型，e是变量而G,L,H是名字绑定<->值
​		enum {R,G,B};
​		R is 1 G is 2 B is 3, R,G,B名字绑定<->值在class外可视为一个#define 
​		class C{
​			enum {G = 1,L = 2,H =3}

		};
		C::G is 1,C::L is 2, C::H is 3 , G,L,H名字绑定<->值在class内可视为一个staic int
	enum class 	
		c++11引入的强类型枚举属于c++的枚举
		有作用域(因此必须有名字，否则什么都做不了)、隐式转换受限(可显式转换)、可指定底层类型(即枚举实际存储类型)

内存管理*
	free/delete NULL是安全的，什么都不会发生，因此指针释放内存后建议若不销毁将指针置为NULL
	解引用 NULL则造成Segmentation fault
	内存越界 
		越界超过页，访问没有映射的页或没权限的页则造成Segmentation fault
		mallloc的有效内存越界，free异常
	野指针 内存单元被释放，指针没有设置为NULL,然后指针指向的内存可能被分配给其它程序使用，难以预测的错误
	重复释放 内存单元被释放，指针没有NULL,再次释放会free异常
	内存泄漏
	智能指针
		unique_ptr 
			禁止了拷贝构造->unique,仅保留移动构造 , 支持移动不支持拷贝
			对象所有权仅能通过move转移，转移后，被转移unique_ptr失效
		shared_ptr
			引用计数，可复制，复制导致引用计数增强，底层共享对象
			循环引用造成内存泄漏×，考虑配合weak_ptr
		weak_ptr*
			没有重载operator*和->，协助shared_ptr工作像旁观者一样观测资源的使用情况
			weak_ptr从shared_ptr或者其它weak_ptr对象构造，获得shared_ptr资源的观测权，它的构造不会增加shared_ptr的引用计数的
			use_count() 获得引用计数
			expired() <=>use_count()==0
			lock() 返回shared_ptr对象,不存在时返回存储空指针的shared_ptr
	垃圾回收
		对象不使用时回收，引用计数或可达性标记，来识别对象是否不使用
		受限指针对垃圾回收是安全的，而放纵指针的灵活性，对垃圾回收造成困扰
		
nullptr 
	类型为nullptr_t是一个普通类型不是指针类型，仅能被隐式转化为指针类型，也仅能与指针进行比较运算
	define NULL 0  or (void *) 0，NULL可能可被转化为int类型
	nullptr是一个右值常量
	
lambda 与 functor*
	functor 即实现了operator()的class，functor以成员变量捕获状态，编译器内部labmbda被转化为了functor，functor是lambda的语法糖
	[=] 值捕捉，捕捉的值在定义是确定*
	[&] 引用捕捉，捕捉的值在调用时确定*
	lambda表现为就地编写，就地使用，[]捕获不能跨作用域，functor没有这个限制，lambda是functor的子集
	lambda对象的类型为闭包类型,可使用auto标识符接收lambda对象对象
	std:function	
		一切Callable对象的类型安全的wrapper，可实现对一切Callable对象的存储、复制、和调用操作
		Callable对象括普通函数、Lambda表达式、函数指针、functor
		
通用属性
	[[]] 对类型、变量、名词、代码块进行注解，为编译器提供更多信息，利于编译器优化
	
字符&字符串	
	unicode
		ucs 编码方式，对现实世界文字、符号的码表，定长，每个二进制对应一个字符
			ucs2 2字节 
			ucs4 4字节
		utf 实现方式 对ucs的编码(编码的编码)
	原生字符串 R""，不转义
	
函数重载
	名字修饰机制，以支持重载
	c语言没有此机制，因此extern "C",与c兼容不修饰
	extren C的函数在namespace内不起作用，名字可能没有冲突报错，但可能被解析为相同的函数