.hpp
	inline函数
		非inline函数编译器只需要在调用位置知道函数的声明，具体的函数地址由链接器处理
		函数inline时由编译器在编译时在调用位置展开，因此在每一个展开位置，函数的定义必须对编译器可见
		因此每一个调用位置要有inline函数的定义，建议将inline函数定义在头文件中，然后在调用位置的文件#include该头文件，而无需复制代码
		如果非inline函数定义在头文件，被多个文件include则会造成非inline函数的重定义，链接时会报错，一般头文件仅放置非inline函数的声明
	template
		同理编译器实例化模板时，编译器也必须看到模板函数/类的定义		
	classes 
		实例化对象时编译器必须看到类的定义，来为对象安排内存
	#编译器处理的部分必须看到完整的定义，而只需要声明的是留给链接器去处理
			
#templates机制在编译时某些不确定会引起歧义，因此需要引入一些特别的标记，标识这种情况，消去歧义
#模板没有被实例化之前是不存在的，实例化才生产出来，生产出来才是一个普通的class或function
#模板是Duck Type的
#模板参数中 非引用类型会出现数组->指针的转型(decay)，引用类型不会转型

函数模板
	模板参数要求完全匹配，不存在隐式类型转换*
	template<typename T,typename RT> 
	RT f(T i); 
	不指定类型在模板会进行类型推导，但无法对返回值类型推导;如f(0),T推导为int，而RT无法推导，因此必须f<int,bool>(0)
	重载的模板函数和重载非模板函数共存，非模板函数优先
	template<typename T> void f(T& a);
		T&参数的类型演绎不会发生退化
		int a[5];f(a); T is int[5], isn't int*
		const int a;f(a); T is const int, isn't int
		f("Apple");T is char[6], isn't char*
		

成员函数模板	
	存在成员函数为模板
	class Stack{
	template<typename T>
		f(T i);
	};
		
类模板
	template<typename T>
	class Stack<T>{...};Stack的类型为Stack<T>
	惟有被调用到的成员函数,才会被实例化*
	#typedef 并不产生新类型,只是为既有类型产生一个别名,typename告知编译器被修饰的名称为类型
	模板参数可以赋默认值，可以引用前一步定义的模板参数赋值
	实例化和template<>都可以产生特化体，template<>可以部分特化

模板参数 
	类型参数
	非类型模板参数(值) 
		函数 实参->形参 类比 模板 自变量->模板参数
		模板参数可以为类型typename，也可以不为类型(为值)
		类型有局限,不能使用浮点数、class-type 对象、内部链接(internal linkage)对象	
		总是右值(rvalues):它们不能被取址,也不能被赋值
	Template template parameters
		class templates 占位符号，代表被占位位置是一个模板类，调用时对应位置为一个模板


代码组织
	置入模型hpp
		no-inline function templates 不在调用端展开，而是在调用端创建实例化的拷贝一份，不同文件调用可能产生相同函数定义,ld可能报错重复定义#namespace的必要性*
		inline function templates 实例化后被展开，不生产函数
	显式实例化 
		template class Stack<int>，明确要求编译器在此位置产生一个实例化
	分离模型 
		export编译器支持不完全
	预编译头文件 
		编译器支持不完全
		程序中往往有很多文件一开头都含入了相同的程序，将不同文件的相同代码，编译器出来导出到一个预编译头文件中
		
虚函数
	类的模板化的成员函数/成员函数模板
		不能为虚函数，因为编译期间无法确定是否实例化，无法安排虚表
	模板类的普通成员函数
		class template的members function class是模板里面定义的成员函数，此函数可以为虚函数，实例化后class变为普通class，成员函数数量固定
	模板的方法是随需要实例化，但虚函数一般需要安排虚表->虚函数，因此需要提前实例化
	
名字查找
	ADL 
		普通函数名字查找在当前作用域找不到时会在参数关联的namespace和class作用域范围内查找同名函数
		ADL查找并不包含using引入此作用域的名字，是直接定义在作用域的名字
	限定修饰*
		受限名称 :: -> 限定了作用域
		template后的<被认为是模板的开始，当在引用出现id<>时，为表明id为模板需要使用template修饰
		typename 限定修饰 名字为类型
	模板名字查找
		非依赖名称 在遇到时就查找
		依赖性名称(名称依赖模板参数) 在实例化时才查找
		
模板两阶段编译	
	类型无关编译，此阶段因为类型不确定，因此不能处理与模板参数T相关的依赖性名称
	POI 实例化点编译，模板实参确定，处理依赖性名称
	POI 
		源代码的一个点，在此位置会插入具现化的代码   
		调用(隐式实例化，目标参数的类型推导仅适用于函数，不适用于类)/显式实例化引发模板实例化
		
多态
	继承+虚函数 运行时多态 
		多个相关类型确定一个共同功能集，在基类中将共同功能声明为多个虚函数
		接口是预先确定，接口绑定是在运行期
	模板+类型推导 编译时多态
		接口是非侵入式的(Duck Type)，预先没有确定，接口绑定在编译期
		#运行时动态传入的值，策略，callback，类型等信息，通过模板在编译时传入，实现编译期多态
		#值，策略，callback，类型等信息都可以包含在class中
		
模板参数的辅助
	#为泛型引入辅助泛型，trait配置辅助属性(值/类型)，policy配置辅助行为(算法)
	#可减少模板参数个数
	trait 
		表述了模板参数的自然额外属性
		为主类型声明一个关联类型trait模板，triat是主类型关联的额外信息，额外信息可为类型，常数，值等
		技巧
			在trait类中typedef 模板参数T，可以返回主类型信息
			在trait类定义值，返回主类型值信息
			为关联的主类型特化trait类型
	policy
		表述了泛型函数/类的可配置行为
		
继承*0
	模板参数为父类,不同的模板参数父类间接为模板类引入不同的特性*
	crtp 模板参数为子类，子类将自己作为参数传递到父类,父类可以对子类共有特性抽象
	ebco
		成员类没有ebco机制，为获得最优空间布局下，可以将可能为空的类封装为某类的父类,将不可能为空的类封装为某类的成员
		
元编程
	状态变量 模板参数
		值 编译时常量
		类型 类型为变量，定义的空类型class/struct，用以指示信息
	迭代 模板递归
	分支 条件表达式/特化/函数重载/IfThenElse<Cond, ... , ...>
	enum {整型算法}
	inline辅助函数 辅助函数利用函数的类型推导机制提供更易用的接口
	auto&sizeof背后隐藏了cpp的类型推导机制
	
智能指针的异常安全性保证
	异常发生，控制流打断，不保证释放资源代码执行
	构造异常，析构不执行
	智能指针持有资源，无论异常是否发生，离开作用域时编译器析构智能指针，智能指针保证资源释放
	RAII模式
	
仿函数&回调
	#c++filt可还原修饰名
	宏/函数指针/函数对象/函数引用/成员函数指针
	直接，间接，内联
		内联调用是不调用没有函数调用开销，且编译器可以更多优化
		函数名称确定时，编译器生成直接调用指令，由链接器填写地址，call addr，开销小于间接调用
		名称不确定指定间接调用，如函数指针，运行时才获知绑定地址，call [addr]
		基于模板生成回调，有利于生成内联和直接调用的代码，template callback is perf
		能直接调用才有内联的机会，因此用functor代替函数指针性能更好
	纯函数
		仅从实参->形参输出数据，仅从返回值输出数据，不和外界环境交互，
		无副作用(函数副作用指,被调用函数除了返回函数值之外，还对主调用函数产生附加影响)
	基于class的functor
		可以携带状态信息
		可以携带元信息，以支持内省

=========V2=============	
类型萃取的接口简化
	::value  => _v  
	::type  => _ t 
	
未在标准的语言特性Concept
​	静态多态接口约束，explicitly provide(and check) interfaces for template parameters.
​	模板参数以Concept描述了接口约束 , 不满足Concept接口约束的模板实参将不能成功实例化模板
​	当前一些标准库使用enbale_if 配合各种trait方法施加一些约束，concept/std::enable_if 可以为DuckType的T施加约束，当约束不满足时模板被禁用

模板参数类型推断
	如果参数按引用传递则不允许类型转换
	如果按值传递允许类型decay，decay 类型退化已知行为有去掉const , voliate，&修饰等，数组，函数->指针
	auto和T的推导规则大部分类似
	T&& 转发引用， 唯一将模板参数T隐式推断为引用的情况 
	auto&& 万能引用
	
noexcept
	https://blog.csdn.net/craftsman1970/article/details/82858285 
	
复合类型
	包括指针类型，左值和右值引用类型，成员指针类型和数组类型。 它们由一种或两种基础类型构成。 类类型和函数类型也是复合类型，
但是它们的组成可以涉及任意数量的类型（用于参数或成员）。 即使枚举类型在此分类中也被视为非简单复合类型

元编程技巧
	为复杂的不能自动类型推导的函数使用内联包装函数模板提供完美的转发
	使用包扩展将类型列表迭代任务交给编译器
	使用decltype , std::declval<T>() sizeof , sizeof... 将类型推导任务交给编译器
	static_assert 触发一个编译期错误
	
tuple的实现方式            
	cons style 是基于递归pair的list风格
	基于...的typelist风格