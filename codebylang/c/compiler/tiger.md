词法分析
	字符来自字母表，语言是字母表*的子集(满足规则的部分)
	regexpr
		基本结构
		运算符 | concat * 
		扩充运算
			? 0-1

			+ 1-n
			[abcd]/[a-d] (a|b|c|d)
			. 除换行任意一个字符
	定义规则消除二义性
		规则优先 第一个匹配的规则优先
		最长匹配 到达停止状态时，记录下来继续向下分析，直到不能分析(无对应转换)，根据记录获取最长匹配位置
	lex
		yytext 匹配的字符串
		yyleng 匹配的长度
		yylval 存储匹配字符串语义值，被语义分析器使用
		int yylex(void);	
			是lex生成的词法分析程序,每次调用返回一个匹配到的TOKEN类型
			其它信息被写在特殊的全局变量内
语法分析
	语法 组合Token形成短语，句子
	<S,NT,T,P>
	LL(k)
		递归下降 eat掉T，调用NT()
		消除左递归，计算first,follow集合并求得选择集合
		提取左因子合并产生式
	yacc
		冲突 
			默认 
				移进-归约冲突 移进
				归约-归约冲突 声明顺序
			优先级指导
				优先级 声明顺序 / %prec
				结合性 %left,%right,%nonassoc
		error
			专门匹配出错的一串token
			try插入，删除，替换出错点前的K个单词，以尝试是否能继续分析下去 #需要回溯
			修复位置<-错误点->继续前进单词数，修复能使错误点向前前进单词越多质量越好
			在try模拟分析时，不执行语义动作(语义动作可能有副作用)，修复后正常分析才执行动作
			%change 指定优先尝试修复动作
		语义动作 
			A ->B "+" C  {$$ = $1 + $3}
			每个T和NT符号关联一个语义值，$i引用第i个符号语义值,$$引用左部语义值
			yacc维护两个对应的栈：状态栈和语义值栈
			语义值关联
				%union 声明了符号的语义值关联的可能的类型
				<>为符号指定关联的语义值的类型
				%union {string id;int iv; float fv;}
				%token <id> ID
				%token <iv> INT
				%token <fv> fv
		ast
			定义一组ast的数据结构，语法分析时执行动作构建ast,传递给后续阶段，不直接进行语义分析 #lex->yacc->ast 
			ast节点需增加一个记录当前节点在源文件位置对应节点，如pos(filename,line,col)
			生成ast后，后续阶段可以多趟遍历语法树来收集信息
			

语义分析
	变量的def和use联系起来、类型检查、中间代码生成
	Symbol Table
		破坏式scope 
			进入作用域，使用stack记录插入的新符号(新符号会隐藏因此存在的上层作用域符号)，离开时根据stack的记录删除插入的符号
			hash表采用拉链法，则新老符号被hash相同bucket,采用头插法，新符号位于老符号前面，隐藏了老符号
		函数式scope
			进入scope生成新的Table,将Table串联起来,而不直接在老的Table修改	
	标识符有两个名字空间，分别是类型空间和变量和函数空间
	类型环境~类型空间
		标识符是一个类型 #class，基本类型，数组，typedef/using定义的类型别名	
	值环境～变量与函数空间 
		标识符是函数/变量，记录值和所属类型等		

frame 
	frame布局的标准化，使不同程序可互相调用
	定义一组与target无关的frame接口（创建、访问、销毁、静态链），隐藏不同target具体实现的布局
	逃逸变量分析
		遍历ast,遇到变量符号逃逸变量信息，设置符号表escape区域
	将检查和翻译分开，避免模块复杂丑陋 #模拟器执行逻辑和检查逻辑分离



指令选择
	每个指令	对应1-几个IR tree段（瓦片）
	指令选择 使用瓦片覆盖IR tree
	最优 每个指令有不同代价，选择代价最小的覆盖
	最佳 相邻瓦片连接组合不能形成代价更小瓦片
	最大匹配 贪心算法 每个节点选择最大瓦片覆盖(覆盖节点最多) 最佳覆盖
	动态规划 

​		划分子问题，找出递推关系，**如何对局面/状态编码记忆**

```
// create by luchaoyi
// 一颗子树的根节点唯一的代表了整个子树, 地址具有唯一性
def hash_key(tree t):
	return &t; 
	
// 对subtree进行记忆避免重复搜索
ValueDict ={key:[value,pattern]}
def dp_match(tree root):
	key = hash_key(root);
	if key in ValueDict:
		return ValueDict[key].value
		
	v_min = +INF;
	mp_min = none;
	for mp in mattch_patterns:
		subtrees = split(root, mp); //子树拆分
		vmp = cost(mp);
		for st in subtrees:
			vmp += dp_match(st);
		if vmp < v_min:
			v_min = vmp
			mp_min = mp
	ValueDict[key] = {v_min, mp_min}
	emit(mp_min); // 发射符合mp_min的指令
	return vmin;
```

活跃分析
	逆数据流方向的分析 
	冲突图 
		活跃范围重叠的一组变量不能分配到同一个reg
		存在冲突的变量连一条边表示冲突
		在一个范围内根据活跃信息就可以构造出冲突图
	流图 
		node属性
			def: node中定值的临时变量表(对应目标寄存器位置)
			use: node中使用的临时变量表(对于源寄存器位置)
			is_move: 是否move指令，move当def和use相同时可删除指令
			info 指向instr(表示汇编指令)的指针，以上三个属性从instr获得
		edge 
			根据instr的jump，来创建cfg的edge
			
寄存器分配
	基于简化的图着色(K个颜色/寄存器)
		1.重复删除度数小于K的节点，并记录在栈
		2.剩余图G度>=K,标记一个节点表示它要溢出spill,删除它，转1，直到图G为空转3
		3.pop stack
			重构图分配颜色
		    对于标记溢出节点，尝试是否存在着色，如果不能着色则放弃
		4.对于不能着色的节点改写程序添加spill，使用变量之前从存储器读取,定值后写回存储器
		5.转1,直到没有溢出产生

```
0: x = 1
...
10 :y = x +1 
活跃范围 [0, 10]
0： x=1
1:  M[i] = x  //store 
...
9: x= M[i]
10.y = x +1 //load 
spill插入的load 和store将活跃范围拆分为了更小的[0,1] [9,10]；降低了和其它变量冲突的概率
```

​	合并
​		move指令的dst = src在冲突图没有边，则冲突图两个节点可合并(不冲突，且赋值)
​	 预着色 - 节点需要指定具体的寄存器
​	 	节点不能溢出和简化
​	 	跨call活跃的变量分配到func(called)保护的寄存器
​	 	局部变量和非跨call活跃的变量分配到caller保护的寄存器



垃圾收集
	收集掉不活跃的，很难得到所有活跃信息，退一步清理掉不可达的
	标记清除 
		freelist 将不可达对象挂到freelist[i]链路，下次申请某大小空间，直接从表头取
	引用计数	缺点环，代价大
	复制回收 
		宽度优先 复制后指针转写简单，但局部性不好(子节点离的远)
		深度优先 指针转写比较复杂
	运行时对象垃圾回收 需要获取到每个指针指向的对象的数据布局信息



函数式
	纯函式 
		无状态和副作用
		初始化后禁止修改变量，每次只能产生新的变量，无赋值
		无循环 使用递归
	高阶函数 使用函数为参数和返回值
	闭包*
		作为参数或返回值的函数表示为闭包
		代码地址
		非局部变量访问途径，如静态链
	g(x) = func add(func f,int x) {return f(x) + x;}
	堆分配活动记录
		基于静态链的闭包，add函数返回时不能销毁活动记录，因为g(x)还要引用add的x
		或
		stack frame保留一个指针指向heap，保存逃逸变量，将head链接起来
	优化
		内联
			变量重命名， 将函数内联的位置，变量可能与外层函数变量名冲突		
			避免指令爆炸的内联规则
				频繁调用函数
				小函数
				只调用一次的函数，然后死函数删除，删除原始函数体副本
		闭包变换 非局部变量访问转换为形参的访问
		尾调用优化
	惰性求值 
		传名调用 在变量创建的位置生成一个函数,函数求值得到变量，在变量使用的位置放置函数调用



加快数据流分析
	bit向量表示集合 #gen{} kill{}

​	基本块合并 

​		n->p, p只有一个前驱n，n只有一个后继p，则n和p可以合并为一个block,以加快分析

​		一般经过某些优化后会产生此类型的基本块关系	

​	迭代顺序

​		前向数据流分析在CFG上以RPO(深度优先顺序)迭代

​		后向数据流分析在逆CFG上以RPO(深度优先顺序)迭代

​	以WorkList形式迭代

​	稀疏分析 

​		在SSA graph上传播数据流信息，越过无关指令

​		SSA edge跨越基本块传播时使用CFG信息进行传播	

值编号算法

​	对值和表达式编号，从hash T查找值/表达式编号若没有找到则总编号N = N+1, 将N作为查找对象的编号 

循环优化

​	回边

​		n->h的边，h支配n

​		每条回边对应的存在一个构成循环的子图

​	前置节点 在自然循环外插入一个空的循环节点

​	循环不变量

​		基本 ai是常量，ai到达定值在循环外

​		传播 ai只有一个到达定值是循环不变量

​	归纳变量的发现

```
#基于模式规则匹配的简单算法
基本归纳变量:
i = i + c ,i = i -c等
导出归纳变量
k = j * c , j= j +d; j为归纳变量
...
```

**SSA**

普通形式转为SSA 

```
1.cfg求解all node n的支配边界df[n]

2. 对每个变量a,找到它的def site node n, 在每个df[n] place phi ，并将次位置加入到变量a的def site集合 //因为phi也是定值
3.对变量a放置过phi函数的node标记避免重复放置,因为多个前驱仅需要放置一次

4.从Dom tree的root节点开始dfs遍历所有node, Rename 所有变量
  使用栈记录变量版本好，在离开node时弹出恢复到父节点的版号记录
```

**Lengauer-Tarjan算法**

cfg->dfs **tree**

​	a是b的真祖先则dfnum(a) <dfnum(b), 反之不成立因为**先访问的兄弟节点序号也小于后访问的节点**

​	r...->d...->n

​		d dom n 则d一定是n的祖先, dfnum(d) < dfnum(n) #反之不成立 =>因此，若dfnum(d) > dfnum(n)则d一定不是到n的必经节点 =>因此，首先要寻找dfnum(d)<dfnum(n)的，然后考察d是否为必经节点

​		n的必经节点d一定位于根节点r到n的生成树路径之间，即dfs tree 中从r到n的路径上的**真祖先节点为dom 的候选节点**

​		若n的祖先x(位于候选集合)不是dom 节点则x之上一定由一个旁路在**x之上分叉在x之下（n或n之上）与生成树路径汇合**，旁路使x不是dom node , 而**旁路上的节点不位于生成树路径不是它的祖先dfnum大于n**

​	n的半必经节点s
​		存在s到n的路径，且此路径上的节点(不包括s和n)都不是n的祖先,	即路径上任意节点x dfnum(x)>dfnum(n)

​		此条从s到n的节点就是一条旁路路径(生成树路径上的祖先节点dfnum(x) < dfnum(n))		

​		s是满足上述条件中，dfnum最小的节点，**sdom节点是dom节点的候选**（范围进一步缩小）

​		**sdom定理** 对于cfg中的n的所有前驱v
​			**基本** v是n的**真祖先** dfnum(v) < dfnum(n), 则**v是semi(n)的候选** 
​			**归纳**(传播) v不是n的祖先 有dfnum(v) > dfnum(n),则对v的每个祖先u(包含u=v)，add semi(u) inito semi(n)的候选 ;

​			证明 

​				因为semi(u)->u满足路径条件

​				v不是n的祖先，u是v的祖先，u到n的路径（u->v->n）是一个不在生成树路径上的旁路因此dfnum(u) > dfnum(v)，已知dfnum(v) > dfnum(n)

​			因此， semi(u)...->u->v->n 此路径满足条件 

​	所有候选中dfnum最小的是n的sdom半必经节点 

​	**dom定理**

​		从semi(n)到n(包含n)的生成树路径上，y满足dfnum(semi(y))最小则

​		idom(n) = semi(y) == semi(n) ? semi(n) : idom(y)

SSA上的数据流分析和优化沿着SSA grpah（def-(value)-uselist）和 CFG 稀疏传播

必经节点性质 因为单赋值因此**一个变量的def是它的每个use的必经节点**

**依赖**

没有控制和数据依赖的语句可以并行执行

数据依赖
	w;r  def v;use v; def-use非常明显
	w;w def v;def v; ssa不存在
	r;w  use v;def v ssa不存在
控制依赖 A?exec B

​		若 节点 i位于 j 的 post dom 边界集合（即 i is not  post dom j）则 i? j 即j 控制依赖于i, i的指向决定了j是否执行  

​	

流水和调度
	无数据依赖的指令放置在相邻位置将使程序更快 #ILP VLIW superscalar
	数据依赖和资源约束，限制了指令并行
	数据依赖
		构建DAG依赖图，构建展开循环的依赖图 #循环内依赖和循环间依赖
		拓扑排序，排放指令

模调度

​	试图将循环体的所有指令放在一个周期数为T的调度中，T为不同循环轮的启动间距

```
1.根据资源约束和数据依赖环来估算初始启动间距T= T'
2.启发式规则(e.g. 大量使用稀少资源的指令优先)来排列循环体指令顺序，按照规则安排优先指令，然后再它们周围安排其它指令(需要满足约束)
未调度的最高优先级指令h:
	放入满足依赖的最早时间槽内(共T个时间槽)
	若连续T个时间槽都不满足则，h无法调度, 尝试不将和h有资源冲突的已调度指令和h的后继指令取消调度(回溯)，强制调度h
3. 尝试n*c次不能调度所有指令则放弃， T=T + 1
```

​	编译器分支预测
​		启发式规则

​			向后（后向边）的分支(一般是循环分支)一般发生转移; 向前的分支不发生转移

​			指针 p==null or p==q 一般预测为假  #异常情况发生较少

​			... #一般是根据通常情况形成的规则

​		/*
​			arm指令 <opcode>    {<cond>}    {S}    <Rd>,<Rn>,<operand2>
​			S	决定指令执行结果是否影响CPSR寄存器 | write
​			cond 根据cpsr寄存器条件执行 |read
​			CPSR和SPSR是状态寄存器，SPSR是用来保存中断前的CPSR值，中断返回之后使用它恢复
​		*/
​		
存储层次

​	**cache**

​		映射策略

​			直接映射  	

​				整个内存地址采用mod方式hash到cache的不同line

​				电路设计简单，映射速度快，确定cache line大小cache line数量后取addr中间几个位作为key（自然产生mod的效果），key作为index索引cache line; 高位作为tag; 低位为cache line内便宜

​				缺点 映射固定利用率低，可能产生反复冲突适合大容量cache 

​	 	全相联映射 

​			主存中任意一块映射到Cache中的任意位置上

​			利用率高，但调入和淘汰策略复杂，仅适合小容量cache

​		 **组相联**

​			将cache line 划分为组，组间直接映射， 组内全相联映射 

​		写命中策略 

​			立即更新内存

​			从cache写回mem时更新

​		写缺失策略

​			直接写到内存 无cpu停顿，但下次读会产生一次cache miss

​			写到cache目标字位置, 相同line的其它字被标记无效

​			写到cache目标字位置，并加载相同line的相邻字,  会产生cpu停顿

​	数据cache 

​		数据对齐，访问避免跨cache块访问

​		避免bank conflict	

指令cache 
		轨迹调度 

​			频繁执行的路径放在连续的cache块

​			不频繁执行的指令不和频繁执行的指令放在相同的cache块

​		预取的cpu支持
​			预区指令 
​			非阻塞取数 r<-M[a],执行后cpu不等待从地址a io,直接向下执行直到引用r的指令才停顿
​		指令重排序，隐藏二级cache miss#io藏在计算中
​	循环
​		循环交换
​		分块
​		标量替换