Symbol Table
	storage class 
		scope
			嵌套?内层是否允许遮盖外层?
			#llvm scope symbol table 符号表内需要存储作用域的标识(例如指针/路径前缀等)，才能区分相同scope的declare confict和作用域遮盖
		visible 
		lifetime
			
	symbol table
		<hash(k),(k,v)>
		hash + symbol stack + block stack 
			scope
				所有新加入符号表项entry(k,v)都在栈中，block stack保存了每一个scope 在stack中的基址，离开scope则清空基址之上的所有符号
				entry需要一个作用域标识来区分	相同符号是否在同一个scope冲突还是不同scope* 
			拉链
				hash(k)相同的符号头插入链接在一起，形成look up 链
			#这里通过stack 构建scope, llvm通过link list 构建scope
	存储绑定
		变量名->地址，指定一种适合的寻址方法
		global / static 可重定位地址，相对基地址(e.g. pc)偏移
		栈变量 
			相对stack frame offset / 虚拟寄存器
			按照大小排序变量，将变量place 在 合适的align边界上
			数组/大对象
				place in frame, frame过大，造成offset过大           #优化用
				place frame之间，并将指针存储在frame中，间接访问 #通用
	inst load/store
		sym2reg sym引用的存储位置变量存储到分配的Reg load reg, sym 
		reg2sym reg存储内容存储到sym引用的存储位置 store sym, reg 
		消除冗余ld/st
IR
	IR设计
		level,adt,表达能力，优化适应性
		多层次IR
		为某些语法结构设计多种表示，一种表示可能适应于一种特定的优化
		二进制形式 内部集成，二次优化等
			变量 表现为指向符号表项的指针，使用相对位置，保证位置无关性
		字符形式 可阅读
		HIR
			AST	
				有足够信息可src2src，可转换回源代码或转为其它代码
				lower为低层次IR codegen	
		MIR
			四元式 (op, dst, src0, src1)
			适应多种语言和体系结构
		LIR
			与目标机器inst*基本*一一对应
	数据结构
		Procdure/Function
			name
			nblocks :the number of blocks
			ninsts: ninsts[i] is the number of block[i] insts
			base block: inst array
				针对block 需要定义一组，插入删除指令，以及产生分裂block的interface
			succ,pred:前驱和后继
runtime	
	传参
		值传递 
			需要复制 
 			优化，COW编译器确定参数没有被修改时(只读)，可以优化为传引用
 		传地址
 			无复制，对于基本类型若无修改不建议传地址，
 			因为基本类型某些情况下直接放在寄存器(优化)，如果传地址，则强制必须有地址可能会抑制寄存器传参*
 		寄存器分类
 			特殊的
 			调用者保护的
 			被调用者保护的
	共享对象开销
		运行时链接
		位置无关代码
		数据私有副本	
auto codegen
	语法制导GG
		IR转换->模式匹配->代码生成
	附加语义制导
	tree match and dp
		树可以表示为路径字符串集合，利用自动机可以产生匹配规则
		使用dp来计算最小代价匹配
控制流分析
	#循环识别，控制流归类
	基本块 入口仅出口出的线性代码序列
	region cfg的强连通子图
	利用必经节点关系可识别和标识出CFG中的循环
		必经节点关系
			entry->A->B, 从入口到达B必然经过A，A是B的必经节点， A dom B
			自反 B是自己的必经节点 / 非对称(if A dom B and B dom A, then A = B) /传递，因此可表示为树
			直接必经关系 A直接必经B， A idom B
		后必经节点关系
			P->Q->exit, P到达出口，必然经过Q，Q是P的后必经节点 Q pdom Q
		回边	边v->w，w是v的必经节点则，边为回边
		自然循环	对于回边m->n, n和到达m不经过n的节点和边构成，n为循环首节点
		前置节点
			在循环首节点前插入一个新的block,初始为空，循环内外提到外面的代码会插入此基本块
	可归约/结构良好的	
		持续变换最终可归约为单个节点的图，为可归约/结构良好的
		没有goto到循环体内的跳转，有唯一的入口
		语言中避免goto到循环体类似操作，则构造出的为可归约的循环结构#易于优化
	区间分析
		流图划分为不同类型的区域，区域可抽象为一个节点
		区域归约是嵌套的，归约关系可表示为控制树
	结构分析
		对所有控制结构分类，对于源语言的每一种控制流结构给出一个规则 #模式匹配，语法制导
		#优化是模式精确匹配?识别不了的那种是否能使用模式识别?	
数据流分析
	先归纳基本块内的局部分析，然后在cfg进行全局分析
	结构分析 针对结构构造控制流方程，分析更快
	ssa 
		变量作为赋值仅出现一次
	数组
		依赖分析
		最近写树方法*
依赖分析
	顺序依赖 S1必须在S2之前执行
	控制依赖 S2条件不满足时才执行S3                              c
	数据依赖 
		真依赖 S3给d赋值,S4使用d的值，颠倒S3和S4的顺序就会出错 t 
		反依赖 S3使用，S4赋值                                      a
 		输出依赖 S3,S4都给某变量赋值   #写冲突                   o
 		输入依赖 S3，S4都使用某变量值  #读冲突                   i
 	基本块内依赖DAG
 		block内部无control flow, 因此是无环的图
 		edge上等待时间
 		#资源向量!!!
 		每条指令使用资源向量标识是否用到资源/用几个资源，检查资源向量的交集可得到是否存在，资源竞争(结构相关)*
 	控制依赖图CDG
 		以谓词为root节点，以非谓词为子节点，谓词满足则执行语句
别名分析
	存储位置可能通过多种途径被访问
	c别名
		union 
		指针以及它任意偏移
	可能 某条路径发生
	一定 所有路径发生
	流敏感 需要沿着控制流路径，进行数据流等分析
	流不敏感 求解子问题，合并结果
	别名收集器*
		由编译器前端提供，分析语言提供的别名机制，收集别名
		为语句定义别名规则，根据规则生成别名信息
	别名传播器 执行数据流分析，传播关系

