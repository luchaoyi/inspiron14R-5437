## 龙书

### 8 代码生成

**指令选择** 

IR->指令的映射，知道指令的代价很重要，但有时很难获得

**寄存器**

寄存器分配  某个程序点，选择一组变量放在寄存器中

寄存器指派 指定变量存放在哪个寄存器

**代价**

由不同目标决定：编译/运行时间，代码大小，能耗等

**基于DAG的基本块内优化**

为基本块内指令构建DAG->优化->转换为新的基本块

**简单的代码生成器**

reg desc 记录哪些变量值存放在此寄存器

addr desc 记录变量当前值存储在哪些位置,reg,地址，栈位置等

### 10 指令级并行性

**数据依赖**

写后读是真依赖，读需要写的数据

其它依赖不是真依赖，本质是一种资源冲突，可以考虑使用不同的reg解决

**基本块指令调度**

数据依赖图->带优先级拓扑排序

**软件流水线**

挖掘连续迭代间的并行性，交叠多个循环的迭代

根据数据依赖和资源约束可以计算一个启动间隔T，根据T，调度指令

### 11 并行性和局部性优化

数值应用的循环下标和数据访问经常呈现仿射关系，c0+c1x1+c2x2+.... ，n层嵌套loop是一个n dim 的多面体

目标 给一个调度方案将相近的内存访问运算安排在靠近，且多核下尽量安排在相同核上

仿射分划 分划迭代多面体为不同部分，在不同核上执行，以仿射访问的方式对数组操作，没有指针操作，分析相对容易

分块 将太大的数组/矩阵，分块计算在内循环中保证更好的访存局部性

使用affine分析循环中数组内存访问模式，分析依赖关系更好的分划、分块，调度循环

## 花书

link time compile 可利于全局信息优化

run time compile 利用目标环境信息优化

### 4 上下文相关分析

**类型系统**

类型检查编译期则运行期可无类型检查并保证安全运行

生成高效代码

组件 

​	基本类型

​		bool, 数字（浮点，整数（符号?）），字符(ASCII/UNICODE)

​	复合类型合成规则

​	类型等价或兼容判定 

​		名字等价

​		结构与等价

​	表达式类型推导规则

### 5 IR

图IR 图描述算法对象，如语法分析树，数据依赖图（此图拓扑序同一层级节点无数据依赖关系），控制依赖图

线性IR 抽象机上的伪代码表示形式

混合表达 如图表示控制流，基本块内使用线性IR表示无控制流的代码块

#mlir是混合层级且是混合形式的(线性+图（Operation能表示图，由嵌套结构））

### 7 代码形式

编译优化器在IR上进行有限的优化，因此在生成IR结构时应该非常谨慎，生成更优的IR结构，有利于后续优化或代替优化器不能完成的优化

**关系操作硬件支持**

直接条件码 比较操作/算数运算会设置条件码寄存器，cond_br指令根据条件码跳转 // X86

条件复制 增加添加复制指令，条件码选择复制值   //mlir select r3, r2,r1

谓词执行 指令附加谓词，根据谓词决定是否执行生效 ,谓词更利于简单循环，避免了分支的开销，无效指令序列太长会抵消这种好处 //arm

**结构数组布局**

允许对结构体数组元素取地址则布局为多个布局相同的连续的结构单例 {a,b,c|a,b,c...}

不允许对结构体数组元素取地址则可以布局为成员为数组 {a..., b..., c...}

### 9 数据流分析

#### 9.1 迭代数据流分析

迭代数据流分析框架不适用于SSA形式的IR

**不动点迭代**

​	初始集合，方向（-> / <-），迭代公式(传播和汇聚函数) 

​	当不动点迭代具有唯一解，求解与次序无关时可以选择遍历次序优化执行时间

**支配** 

​	bi >> bj, 表示从b0->bj必然经过bi => bj>>bj

​	init = {各节点支配自己}， -> , merge = {前驱节点交集}

​	逆后续遍历更高效

​		后续遍历(先子后父，先坐后右)

​		逆后续遍历 （先父后子，先右后左）

**活动变量分析**	 

use 会在位置激活变量(又成为活动变量的生成gen)

def 会在位置kill活动变量

init  = 扫描基本快的use and def语句，生成基本块内的gen和kill集合 ; <- 

LiveOut(m)   块的出口活跃变量集合 

Gen(m) 此块激活的变量集合

Kill(m) 此块杀死的变量集合 

LiveIn(m) = LiveOut(m) - Kill(m)  + Gen(m) 在块m入口处活跃的变量集合为去掉杀死的加入新生成的 

LiveOut(n) = + [LiveIn(n的所有前驱块...)] ， +即求并集

根据所有变量在所有点是否在活跃集合中，可以得出区间(两个点之间)某变量的活跃性，和某区间保持活跃的变量集合

#### 9.2 SSA

### 11/12/13 代码生成

指令选择 IR->ISA

指令调度(指令重排) 

​	安排指令执行顺序以最大化利于硬件资源

​	关系依赖图 

​		节点上操作类型标识了执行部件，执行周期表示了占用部件时间

​		**解除数据依赖**的操作且**无资源冲突**的节点可并行执行

​	循环软流水

寄存器分配与指派