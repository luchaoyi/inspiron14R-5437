词法分析
	字符来自字母表，语言是字母表*的子集(满足规则的部分)
	regexpr
		基本结构
		运算符 | concat * 
		扩充运算
			? 0-1
			+ 1-n
			[abcd]/[a-d] (a|b|c|d)
			. 除换行任意一个字符
	定义规则消除二义性
		规则优先 第一个匹配的规则优先
		最长匹配 到达停止状态时，记录下来继续向下分析，直到不能分析(无对应转换)，根据记录获取最长匹配位置
	lex
		yytext 匹配的字符串
		yyleng 匹配的长度
		yylval 存储匹配字符串语义值，被语义分析器使用
		int yylex(void);	
			是lex生成的词法分析程序,每次调用返回一个匹配到的TOKEN类型
			其它信息被写在特殊的全局变量内
语法分析
	语法 组合Token形成短语，句子
	<S,NT,T,P>
	LL(k)
		递归下降 eat掉T，调用NT()
		消除左递归，计算first,follow集合并求得选择集合
		提取左因子合并产生式
	yacc
		冲突 
			默认 
				移进-归约冲突 移进
				归约-归约冲突 声明顺序
			优先级指导
				优先级 声明顺序 / %prec
				结合性 %left,%right,%nonassoc
		error
			专门匹配出错的一串token
			try插入，删除，替换出错点前的K个单词，以尝试是否能继续分析下去 #需要回溯
			修复位置<-错误点->继续前进单词数，修复能使错误点向前前进单词越多质量越好
			在try模拟分析时，不执行语义动作(语义动作可能有副作用)，修复后正常分析才执行动作
			%change 指定优先尝试修复动作
		语义动作 
			A ->B "+" C  {$$ = $1 + $3}
			每个T和NT符号关联一个语义值，$i引用第i个符号语义值,$$引用左部语义值
			yacc维护两个对应的栈：状态栈和语义值栈
			语义值关联
				%union 声明了符号的语义值关联的可能的类型
				<>为符号指定关联的语义值的类型
				%union {string id;int iv; float fv;}
				%token <id> ID
				%token <iv> INT
				%token <fv> fv
		ast
			定义一组ast的数据结构，语法分析时执行动作构建ast,传递给后续阶段，不直接进行语义分析 #lex->yacc->ast 
			ast节点需增加一个记录当前节点在源文件位置对应节点，如pos(filename,line,col)
			生成ast后，后续阶段可以多趟遍历语法树来收集信息
			
语义分析
	变量的def和use联系起来、类型检查、中间代码生成
	Symbol Table
		破坏式scope 
			进入作用域，使用stack记录插入的新符号(新符号会隐藏因此存在的上层作用域符号)，离开时根据stack的记录删除插入的符号
			hash表采用拉链法，则新老符号被hash相同bucket,采用头插法，新符号位于老符号前面，隐藏了老符号
		函数式scope
			进入scope生成新的Table,将Table串联起来,而不直接在老的Table修改	
			
	标识符有两个名字空间，分别是类型空间和变量和函数空间
		类型环境~类型空间
			标识符是一个类型 #class，基本类型，数组，typedef/using定义的类型别名	
		值环境～变量与函数空间 
			标识符是函数/变量，记录值和所属类型等
frame 
	frame布局的标准化，使不同程序可互相调用
	定义一组与target无关的frame接口（创建、访问、销毁、静态链），隐藏不同target具体实现的布局
	逃逸变量分析
		遍历ast,遇到变量符号逃逸变量信息，设置符号表escape区域
	将检查和翻译分开，避免模块复杂丑陋 #模拟器执行逻辑和检查逻辑分离

指令选择*
	每个指令	对应1-几个IR tree段（瓦片）
	指令选择 使用瓦片覆盖IR tree
	最优 每个指令有不同代价，选择代价最小的覆盖，
	最佳 相邻瓦片连接组合不能形成代价更小瓦片
	最大匹配 贪心算法 每个节点选择最大瓦片覆盖(覆盖节点最多) 最佳覆盖，但
	DP 最优覆盖
	抽象的汇编指令，没有指定寄存器的指令

活跃分析
	逆数据流方向的分析 
	冲突图 
		活跃范围重叠的一组变量不能分配到同一个reg
		存在冲突的变量连一条边表示冲突
		在一个范围内根据活跃信息就可以构造出冲突图
	流图 
		node属性
			def: node中定值的临时变量表(对应目标寄存器位置)
			use: node中使用的临时变量表(对于源寄存器位置)
			is_move: 是否move指令，move当def和use相同时可删除指令
			info 指向instr(表示汇编指令)的指针，以上三个属性从instr获得
		edge 
			根据instr的jump，来创建cfg的edge
			
寄存器分配*
	基于简化的图着色(K个颜色/寄存器)
		1.重复删除度数小于K的节点，并记录在栈
		2.剩余图G度>=K,标记一个节点表示它要溢出spill,删除它，转1，直到图G为空转3
		3.pop stack
			重构图分配颜色
		  	对于标记溢出节点，尝试是否存在着色，如果不能着色则放弃
		4.对于不能着色的节点改写程序添加spill，使用变量之前从存储器读取,定值后写回存储器
		5.转1,直到没有溢出产生
	合并
		move指令的dst = src,直接在冲突图没有边，则两个节点可合并(不冲突，且赋值)
	 预着色 - 节点需要指定具体的寄存器
	 	节点不能溢出和简化
	 	跨call活跃的变量分配到func(called)保护的寄存器
	 	局部变量和非跨call活跃的变量分配到caller保护的寄存器
	 实现
	 	两种查询
	 		x和y相邻? 邻接矩阵
	 		获取x相邻的所有节点 邻接表
	 表达式树上的寄存器分配
	 	need[t] 以t为根的子树需要的寄存器个数
	 	根据need[t]为分配寄存器
---------------------------------------------------
垃圾收集
	收集掉不活跃的，很难得到所有活跃信息，退一步清理掉不可达的
	标记清除 
		freelist 将不可达对象挂到freelist[i]链路，下次申请某大小空间，直接从表头取
	引用计数	缺点环，代价大
	复制回收 
		宽度优先 复制后指针转写简单，但局部性不好(子节点离的远)
		深度优先 指针转写比较复杂
	运行时对象垃圾回收 需要获取到每个指针指向的对象的数据布局信息
	
面向对象
	私有性一般在类型检查阶段进行
	类型传播分析(类型到达定值分析)，来确定某个点对象属于的class,从而将动态方法调用转化为静态方法调用
	
函数式
	纯函式 
		无状态和副作用
		初始化后禁止修改变量，每次只能产生新的变量，无赋值
		无循环 使用递归
	高阶函数 使用函数为参数和返回值
	闭包*
		作为参数或返回值的函数表示为闭包
		代码地址
		非局部变量访问途径，如静态链
	g(x) = func add(func f,int x) {return f(x) + x;}
	堆分配活动记录
		基于静态链的闭包，add函数返回时不能销毁活动记录，因为g(x)还要引用add的x
		或
		stack frame保留一个指针指向heap，保存逃逸变量，将head链接起来
	优化
		内联
			变量重命名， 将函数内联的位置，变量可能与外层函数变量名冲突		
			避免指令爆炸的内联规则
				频繁调用函数
				小函数
				只调用一次的函数，然后死函数删除，删除原始函数体副本
		闭包变换 非局部变量访问转换为形参的访问
		尾调用优化
	惰性求值 
		传名调用 在变量创建的位置生成一个函数,函数求值得到变量，在变量使用的位置放置函数调用
		
多态类型
	类型等价 结构等价，名字等价
	类型check+推导-> 显式带类型中间语言
	多态变量表示（如何表示一个泛型T）
		扩展(实例化)，不生成多态函数，在每一个实例化点生成单态函数 #代码膨胀
		
加快数据流分析
	bit向量表示集合 #gen{} kill{}
	def-use chain
	ssa形式
	工作表 记录变化收到影响需要更新的集合，而不是更新所有集合
	
SSA*
	
	cfg->dfs tree
		dfs顺序为cfg节点赋予序号	
		r--->d---->n if d为必经节点则一定有dfnum(d) < dfnum(n) #反过来不成立
		若dfnum(d) > dfnum(n)则d一定不是到n的必经节点
		因此首先要寻找dfnum(d)<dfnum(n)的，然后考察d是否必经
		n的半必经节点s
			存在s到n的路径，且此路径上的节点(不包括s和n)都不是n的祖先,	即路径上任意节点x dfnum(x)>dfnum(n)
			s是满足上述条件中，dfnum最小的节点
			定理：对于cfg中的n的所有前驱v*
				v是n的真祖先 dfnum(v) < dfnum(n),则v是semi(n)的候选
				v不是n的真祖先 dfnum(v) > dfnum(n),则对v的每个祖先u，add semi(u) inito semi(n)
				所有候选中dfnum最小的是n的半必经节点
		
	依赖
		w;r  def v;use v; def-use非常明显
		w;w def v;def v; ssa不存在
		r;w  use v;def v ssa不存在
		控制依赖 A?exec B
			...
	phi的翻译	对于y<-phi(x1,x2,x3...),在包含phi的基本块的每个前驱插入y<-xi #每条边使用move指令实现phi函数
	
流水和调度
	无数据依赖的指令，相邻将使程序更快 #ILP VLIW superscalar
	数据依赖和资源约束，限制了指令并行
	数据依赖
		构建DAG依赖图，构建展开循环的依赖图 #循环内依赖和循环间依赖
		拓扑排序，排放指令
	最小启动间距～循环软流水周期数
		设定周期T,尝试调度指令
		检测是否违反约束，资源约束和数据约束
		增大T直到满足约束
	编译器分支预测
		向后的分支(一般是循环分支)向前转移，向前的分支不发生转移
		启发式规则
		/*
			arm指令 <opcode>    {<cond>}    {S}    <Rd>,<Rn>,<operand2>
			S	决定指令执行结果是否影响CPSR寄存器 write
			cond 根据cpsr寄存器条件执行 read
			CPSR和SPSR是状态寄存器，SPSR是用来保存中断前的CPSR值，中断返回之后使用它恢复
		*/
		
cache 
	数据对齐，访问避免跨cache块访问
	指令 
		轨迹调度 频繁执行的路径放在连续的cache块
		预取的cpu支持
			预区指令 
			非阻塞取数 r<-M[a],执行后cpu不等待从地址a io,直接向下执行直到引用r的指令才停顿
		指令重排序，隐藏二级cache miss#io藏在计算中
	循环
		循环交换
		分块
		标量替换
