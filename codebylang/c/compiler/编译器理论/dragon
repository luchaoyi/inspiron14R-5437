词法分析
	符号表 是一个数据库，增删改查，主表关联多个表(名字不同的种类建立不同的符号表更加方便),记录名字的信息	
	<token,value>
	regexpr -> nfa
		基本规则 nullable和基本字母
		归纳规则 运算符规则
	nfa -> dfa 
		子集构造算法构造dfa 多个节点集合构造为一个节点;使用于多次使用此模式
		模拟 不转换nfa为dfa而是通过子集构造的边运行，边构造 适用于一次使用模式
		#某些regexpr匹配的库compiler regexp应该就是直接转换为dfa，多次匹配此模式可加快速度
	化简dfa - 状态集合划分
		开始包含两个集合 accept和not accept表示两个节点
		若集合内节点有边跨越此集合，集合应该分裂
		直到所有集合内的边都连接集合内的节点
	直接reg expr构造dfa 
		(r)# -> ast 构造正则表达式的ast
		计算ast每个节点的last,first,null -> follow
		根据last,first,null，follow计算state和trans rule构造dfa
语法分析
	#为文法附加动作可以增强文法的能力不一定使用更复杂文法
	消除歧义
		消除左递归
		提取左公因子 将决策延迟了
	LL(1) / 递归下降语法分析
		通过first和follow集合构造选择集合
		递归下降/表驱动分析
	LR文法
		LR(0) .扩展文法构造项目集和DFA
		SLR(1) 
			LR(0) + follow集合
			看当前一个符号和 follow集合消除移入归约冲突
		LR(1)			
			扩展LR(0),在项目集增加展望符，具体到一个符号而不是符合集合(follow集合)
			不使用follow集合，follow集合提供的信息太泛
		LALR
			LR(1)的项目集太大,状态太多
			方法1
				构造LR(1)项集，合并核心项目集
				例
					假设LR(1)有两个状态,识别语言c*dc*d
					C->d. c/d s1
					C->d. $   s2
					读入cc...cdcc...cd$
					读入一串c后读入d,s1状态归约为C，读入第二个d，s2状态归约为C
					s1和s2合并为s12 C->d. [c/d/$],行为和以前一致，归约C
					合并后在合并前s2下当前符号如果是c/d则会报错，而合并后s12会归约，但是错误只是被延后了并不会消失
					#相当于比LR(1)向后多看了一个符号	
		移入归约冲突，当前符号不在follow集合的不能归约
		归约归约冲突，存在二义性
		表压缩 基于很多状态都有相同的动作，可以使用指针指向相同的动作空间复用
		
制导翻译 #翻译方法
	属性文法 
		SSD 属性和文法符号关联，规则和产生式关联
		描述语义规则的文法，扩展上下文无关文法(语法规则)，为每个文法符号附加一组属性，代表与符号关联的信息,如类型、值、代码序列、符号表内容等
		为每个产生式附加了一组语义规则(属性[值/类型等]计算，静态语义检查，符号表操作，代码生成等)，对属性进行计算和传递
	综合属性 
		根据子节点和自身信息计算，自下而上的传递信息
		仅有综合属性的属性文法称为S属性文法
	继承属性 
		根据父节点或兄弟节点传递的信息和自身信息计算，自上而下传递信息
		表示上下文依赖关系很方便 #扩展了上下文无关文法的表达能力		
	A -> a
		对产生式left的综合属性和产生式right的继承属性都必须提供计算规则，且只能使用产生式中的文法符号的属性
		产生式left的继承属性和产生式right的综合属性不由产生式计算规则计算，由其它产生式计算或直接提供参数
	属性计算
		构建属性依赖图，按拓扑排序计算属性,要求依赖图无环
		遍历语法树计算属性
		一遍扫描(语法制导)
			S/L属性文法一定没有环，可以在语法分析同时进行属性计算 
			每个产生式配备语义(属性)计算规则，在语法分析同时计算语义规则(语义分析) *
	翻译模式 
		为属性计算规则规定次序等实现细节即语义动作
		文法 + 语义规则 + 计算次序和实现细节(语义动作)
			属性文法		| 翻译模式	
		E->...A...
			计算A的继承属性的动作插入到紧靠A之前的位置
			计算产生式头E的综合属性动作放在最右端
	递归下降分析器
		综合属性 返回值
		基础属性 输入参数 
		产生式中的属性 局部变量
				
中间代码生成 #语言各种结构的翻译策略
	hash vs rb tree
		hash O(1)查找速度，但有空间浪费
		rb tree O(lgn)查找速度，无空间浪费
	dag ast的变体，在生成node时检查是否已经存在
	ssa*
		ssa形式的ir主要用于机器无关的优化
		每一次赋值针对不同名字的变量
		Φ(phi)函数
			相同变量在不同控制流路径被定值，phi函数将两个定值合并起来
			if (flag) x1=-1;else x2=1;
			x3=phi(x1,x2);根据到达phi函数的=语句的不同控制流路径，phi函数返回不同参数值
			支配边界
				当节点B的直接前驱A不严格支配B在B在其直接前驱A的支配边界
				A
				 \ 
				  ->B
				 /	
				A'
				B有两个立即前驱A和A',A和A'不能严格支配B因此，B在A和A'的支配边界中，因此B应该生成Φ	
			精简的SSA 
				#全局分析
				Φ函式将控制流浓缩为赋值，通过对定值变量的活跃分析，来决定是否有必要生成Φ函式
				在插入Φ函式的阶段，使用活跃分析来决定Φ函式是否需要，原始变数名称在Φ函式插入点内已经不再使用，则Φ函式将不会被插入
			半精简的 SSA 
				#基本块内活跃分析
				试图减少Φ函式的数量，而不承担高成本的运算活跃变数资讯
				基于以下的观察：如果一个变数从未活跃于一个基本的区块，它就不需要一个Φ函式
	类型
		编译时名字只能分配一个相对地址offset
		类型等价 名字等价/结构等价
		类型转换
				可以在三地址代码中的运算符中带上类型信息，如在中间代码区分浮点运算和整型运算int+、real+、=int2real
				翻译赋值语句时可以进行类型转换和类型检查
		类型推导
			若t为类型表达式，S为一个对t的类型变量的一个置换，S(t)为实例
			例：
				t is T[5]类型表达式, S将t中的类型变量T置换为int, S(t)  is int[5]
			类型表达式t1和t2,如果S(t1) = S(t2)则S是一个合一置换
				
	布尔表达式
		计算逻辑值 c = a op b,真的有op运算，按算术表达式翻译
		改变控制流 if( a op b),可能直接生成goto代码，不计算op
		短路运算
			f1 op f2,
			短路运算会使f2没有被执行,如果函数有副作用则可能产生不符合预期的结果
		一遍扫描翻译为四元式
			产生四元式时，转移地址可能无法确定，需要后面更大语法单位出现时才回填
			将待回填的地址分为两类连接为链，E.truelist和E.falselist代表了需要回填为真和假出口的地址
			需要回填的位置可以临时复用为链表指针(union)，同一个链表的需要回填地址相同
runtime
	-
	code
	data|bss
	heap #brk
	.so #ld
	heap #mmap
	stack
	-
	类型决定存储大小，内存布局有对齐要求(pad)
	stack和heap安排在两端，从两端向中间分配可以更大化的利用内存*
	stack
		frame
			-			
					<-sp
			临时变量       
			局部变量      
					<-bp
			机器状态寄存器
			访问链
			控制链
			返回地址
			参数 
			-
		变长数组的栈上分配
			int a[size];
			若编译时无法确定size大小则无法在编译时为a分配空间，a是变长的
			因此在frame中仅保留一个固定长度的指针，指向数组实际分配的区域，分配可以在栈或堆上，但frame仅包含指针		
		过程调用
			调用代码 实现过程调用过程的代码
			返回代码 恢复状态返回调用
			返回代码仅生成一次，调用代码生成n次，因此尽可能将操作放在被调用者的返回代码中*
			frame原则
				参数在被调用者记录的开始靠近调用者
				固定长度项在中间
				变化部分放在frame末尾
		过程嵌套
			一个过程能访问另一个过程的变量
			q{
				val x;
				p{
				acess(x);
				}		
				call p;			
			}
			p和q有可能是递归的
			p的定义位置不是调用位置，根据p的的frame找到q的frame并访问q的变量，一种解决方法是访问链
		访问链	#定义关系
			指向上级作用域frame
			p的访问链指针指向最近的q的frame,p的嵌套深度一定比q少1
			访问链记录的是函数定义的嵌套关系，不是函数调用的嵌套关系,但是访问链指针是frame的一部分，在函数调用过程中设置*			
			间接调用的访问链设置
			q(ptrP) {
				call *ptrP
			}
			p{}
			r{
				q(&p)
			}
			q不知道ptrP的信息，因此要求调用者r将函数作为参数传递时，也传递它的这个参数的访问链信息
		显示表	#定义关系
			维护指针数组，使d[i]指向stack中最顶的深度为i第的frame记录,以便快速查找
		控制链 #调用关系 
			指向调用者		
	heap
		堆管理器特性
			空间碎片少
			分配回收开销低
			关注程序运行时特性，使程序运算更快,如时空局部性
		局部性 cache和层级结构mem
		碎片整理
			不同的容器内容纳不同尺寸的基本内存block
			一个内存块尽量不同跨越页面
			边界标记 
				存储块的两端存放 free/used位标记 以及 块大小
				每次仅查看，被回收的相邻的两个块，接合
			链表
				空闲块链接起来
		常见错误
			内存泄漏
			悬空地址解引用
			NULl指针解引用
			越界访问
		垃圾回收 ~ 开销比较大 + 可完全防止内存泄漏
			必要信息
				运行时需要知道对象类型(内存占用大小)
				对象包含的其它引用对象
				引用指向开始位置，相同对象具有相同引用
			类型安全 ～ 任何数据分量的类型都是确定的
				动态安全 运行时可全部确定
				静态安全 编译时可全部确定
				c/c++ 指针的自由操作使语言不是类型安全的，无法垃圾回收
			开销
				总体运行时间/内存占用/每次运行停顿时间/影响了数据放置，因尽量不影响局部性
				引用计数引入了开销，但避免了长时间停顿(慢刀宰猪)
			可达性
				不需要解引用就可以访问的对象为 root set
				某些语言是受限指针，但是编译优化是在机器码层面产生了隐藏的非受限指针操作
				因此优化时必须考虑提供必要信息，保证垃圾回收的安全性
				可达对象集合改变操作
					对象分配
					参数传递/返回
					引用赋值
					过程返回
			引用计数
				+
					开销分摊，回收及时，停顿较短
				-
					循环引用
					开销大
					局部栈更新很频繁，因此优化考虑不对root set 引用计数
			周期性运行，全面停顿
				标记-清除
				state 
					未分配 -> 未访问(未确定是否可达) ->未扫描(以及确定是否可达，未确定其包含的引用的对象的可达性) ->已扫描
				标记-压缩
					将所有可达对象重新定位到堆区的一端，使得空闲空间成为一块
					重新定位后局部性更好
					标记 -> 为可达对象计算新地址 ->移动可达对象并更新引用
				copy回收
					将空间划分为 跟踪空间和空闲空间 解除对象跟踪和发现空闲空间之间的依赖
					标记时直接拷贝对象到to空间，直到标记完成，所有可达对象被压缩在了to空间，交换from<->to空间
					经历了多轮依然存在的对象被copy了多次
			短停顿
				时间上 r和m交替的增量回收
				空间上 部分回收
				增量回收
					回收(r)与主程序(m)交替运行，用副表记录主程序引入的新改变
					r:o1被扫描
					m:o1 -> o 扫描后更改了引用
					写关卡
						截获未访问对象o的引用写入已扫描对象o1,或将o置为可达，或将o1置为未扫描
					读/传递关卡
						截获对未访问对象/待扫描对象o的读/写，将o set为可达未扫描
				部分回收
					分代 
						大多数对象早逝特性
						将堆区分为多个区域 0,1,2,...n
						n-1区域填满时，对它回收，将可达对象移动到n区
															
代码生成
	IR(三地值码、AST、DAG...) -> 目标机器代码
	指令选择 要考量指令的代价
	寄存器存器分配和指派
	指令排序
	
	基本块
		CFG的节点
		jump -> |连续执行的一块代码 jump|->
		通过跳转指令进入一个基本块的开始(首指令)，通过一条基本块跳转指令离开基本块(最后一条指令)
		代码优化不考虑中断导致基本块的控制流变化
		首指令
			跳转指令将指令序列划分为基本块，因此跳转指令的目标指令和紧挨跳转指令的指令为首指令
		CFG
			B -> C
				B jump C
				B next is C and B cond jump
			jump 到地址，变为jump到基本块，因为优化时可能对基本块指令进行变更
			循环识别 循环中每个节点都存在到达循环入口节点的路径
		后续使用信息
			i: x = c0
			...
			j: y = x + c1 
			j使用了i处的赋值，变量x在语句i处活跃，变量x的后续使用位置为j
		局部优化
			基本块自身优化，单个基本块内部(全局优化分析信息在多个基本块流动)
			为基本块构造DAG
				每个变量有个初始节点
				每个语句s一个节点，节点上附加变量表示语句s是对变量最晚定值(最近一次赋值)的语句，子节点是它的运算分量
				输出节点 出口处活跃，代表其它基本块会用到，需要生成ST
				#杀死，因为产生了变化，因此否定过去
				#优化被抑制
				数组 当不能确定a[i],a[j]是否指向同一元素，因此保守策略认为存在i==j,因此[]=(写)杀死=[](读)节点 
				指针 
					当不能确定p指向哪个,保守策略认为它们可能指向所有元素，因此*=会杀死所有节点,=*关联所有节点(影响死代码消除)
					数组仅杀死关联同一数组的节点，因此指针别名分析很必要
				函数 保守策略假设函数可能改变了它能所有的所有变量
			公共子表达式 
				加入新节点时寻找是否存在运算形同子节点相同的节点
			消除死代码
				找没有附加活跃变量的根节点	
				没有活跃变量 代表计算结果没有被其它模块使用 + 根节点 代表计算结果没有被本模块其它计算使用
				=> 无用的计算 =>消除
			恒等变换
				常量计算(2 * 3 => 6)，低代价转换(x*2 => x<<1)，无用计算消除(x+0)
				转换是一组规则在构造DAG过程中，可以检查是否满足规则执行变换
			优化后的DGA生成基本块
				多个变量一个节点只需要计算一次，结果赋值给出口出活跃变量，多个活跃则使用=
		代码生成
			跟踪记录值存储在寄存器的信息，不产生不必要的LD/ST，ST取决于是否活跃,LD取决于是否存在
			reg desc 哪些变量存在此寄存器
			addr desc 变量存储在哪些位置(reg/mem)
		peephole	检查局部窗口，是否满足某种优化规则
		全局reg分配
			策略 将内循环中使用的几个最频繁的var固定到几个reg上
			图着色reg分配*
		树翻译方案
			匹配树，节点替换，执行动作
			方法1
				将输入的树前序遍历生成串，将树翻译方案转换为语法指导翻译，则可以构造LR分析器
				可以通过增加特殊的产生式来利用机器特有指令*  #产生式即规则，语法/文法皆为rule
				相对简单文法+附加属性、断言和动作比一个复杂的纯文法描述更好
		表达式代码生成
			expr -> expr tree ->附加Ershov数，表示不存储到mem下的reg使用->根据Ershov数生成代码
			寄存器数量受限时生成ST需要溢出寄存器到内存
		dp
			expr -> expr1 op expr2
			expr的最优代码，由	expr1和expr2最优代码的某种顺序组合而成 #子问题
			1.为表达式树T的每个节点n自底向上计算一个Cost数组，Cost[i]表示假设有i个可用reg下，对以n为root的子树求值并存放结果在一个reg的低价
			2.遍历T,根据Cost数组决定哪颗子树应该被保存在内存中
			3.生成代码，首先需要被保存在内存中这些子树生成代码
		
机器无关(全局)优化
	优化
		一种低层的语义转换，基于一些常见的规则和性质，而不是完全理解了程序并生成一个更优的
		公共子表达式
			表达式expr被计算过且里面的变量值没有改变，则可以避免重复计算
		复制(写)传播
			消除公共子表达式时会引入一些赋值语句(=)
			x = t3,若将后续的对x的读尽可能的用t3代替，则x=t3成为了死代码，直接可以消除x=t3的复制操作*
		死代码消除 计算result不被使用，或代码不可达
		常量折叠	编译时推导expr为常量，则后续使用常量代替expr
		代码移动 	将循环不变式移动到循环外，减少内循环的指令
		归纳变量 强度消减	
	数据流分析 
		状态 变量值集合
		分析模式*		
			一个状态集(分析目标)
			基本块B={s1...sn}，IN[B]=IN[s1],OUT[B]=OUT[sn]
			传递函数 随着基本块语句的顺序执行，状态的变换(状态变量的生成以及杀死)
			控制流约束 
				程序执行是状态转换的过程,要考虑CFG中的所有路径
				基本块的IN/OUT(入口处/出口处)的状态集是所有可能路径的所有前驱/后继的状态集合的交汇
				前驱/后继取决于数据流正向分析还是逆向分析
				分析目标的特性决定使用哪个交汇运算(并集/交集)
			步骤
				给定目标
				确定分析方向
				给出传递方程(状态转换)和控制流方程(交汇运算)并由此列出方程式*
				给定初始值，迭代求解
		到达定值 
			到达程序某个点p时，每个变量x可能在程序哪些地方被定值(赋值)
			定值d的程序点p存在路径到达q,且p没有被杀死（新的赋值）则说，定值p到达q,一个路径上的最后定值杀死了先前定值
			优化的保守主义
				指针/引用/函数参数引入了变量别名，此种情况不能确定变量x的定值，因此只能保守认为x被更改 #优化被抑制
			 	编译时无法判断路径不可到达，则假设每条路径都会执行
			 常量/复写传播需要先进行到达定值分析
		活跃变量分析
			x在点p的值是否在从点p出发的路径上使用，是则在x在点p活跃
			defB 在B中先定值  
			useB 在B中先使用，在B的入口处活跃
			寄存器分配需要进行活跃变量分析，变量在活跃区间内(从def到use)占据寄存器，避免ld/st操作
			冗余代码消除，需要进行活跃变量分析
		可用表达式
			从入口到p所有路径都计算了x+y,且求值后到p点x和y没有改变，则x+y在p点可用(算一次就可以)
			if base block B对x,y赋值且后续没有计算下x+y，则B kill x+y
			if base block B一定对x+y求值，则B gen x+y
			求解各个基本块的可用表达式信息，可识别出全局公共子表达式
		数据流分析框架(D,V,^,F)
			D 方向
			值集V和交互运算^
			V->V的传递函数族F
				F是单调的
				可分配 f(x ^ y) =f(x) ^ f(y)
		常量传播
			NAC not a const 
			UNDEF undefine 
		部分冗余消除
			公共子表达式、循环不变式、部分冗余表达式
				
指令级并行
#mlu是cpu+向量机+asic
#gpu 是simd阵列机
	pipeline 
		IF ID EX MEM WB
		不是所有的操作都可以完全流水线化的,如浮点div占据多个时钟周期有时只能选择暂停流水线 #mlu没有stream div是active
		存在依赖使pipeline不能连续进行时，硬件可以暂停pipeline或软件插入nop
	约束
		资源
		控制依赖
			指令i2的result决定了i1是否执行
			投机 * #分支预测
				将nop的cpu空转，改成投机行为，投机失败则不使用result,要求投机行为无副作用
				有空闲资源时可先执行i1(一种预测)
				数据预取，投机性内存访问，提取访存可能访问不可用内存，此时cpu忽略执行
				毒药位 reg <- mem的投机，if mem is invaild , set reg 毒药位,while use it throw exception
				带pred的指令 减少branch,满足cond exec
				M = <R,T>
					R资源集合 
					T 运算集合
		数据依赖
			 真依赖 w r 
			 #不同内存位置存不同值可消除后两种依赖
			 反依赖 r w
			 输出依赖 w w
			依赖关系分析，不需要知道具体存储位置，但需要知道是否指向同一个位置
			数组依赖分析 
			指针别名分析
			过程间参数分析
			reg 
				中间代码生成使用无限多个伪寄存器
				无限多个伪寄存器 -> 有限个物理寄存器 ; 映射会产生存储依赖
				硬件reg rename
					并行性要求不依赖(使用不同的寄存器)和使用更少的寄存器分配冲突(尽量减少寄存器使用,1 reg 多用)*
					硬件reg rename 指令集提供少量reg,映射到内部多个reg 1个外部reg被动态调度到多个内部reg，减少依赖性
				#非数值计算和数值计算表现出不同的依赖特性
		基本块调度
			数据依赖
			block -> 数据依赖图ddg<N,E> N运算，E依赖的运算后续延时
			对ddg带优先级拓扑排序，没有依赖的可流水并行起来
		全局代码调度
			基本块间 数据依赖 + 控制依赖
			投机不能有有害的副作用
			分析路径依赖 =>然后分析基本块内的代码的作用/副作用=>将代码上下移动=>更新数据依赖关系
			支配 src -> dst 入口执行到dst则必然执行经过src; #执行src后不必然执行dst 
			反支配 src -> dst 从src到出口必然经过dst，即执行src后必然执行dst; #执行到dst不一定经过src
			
			指令/代码移动*
				移动不相关指令代替nop
				当产生数据依赖时为保证正确性，需要插入nop或暂停流水线使先执行的指令执行完成后，依赖的后续指令才能继续执行
				将不依赖的指令调度到互相依赖的两个指令之间以代替气泡(nop)或避免暂停流水线，使资源充分利用
	循环的软流水
		数值应用经常表现出循环内各次独立的特性,do-all特性，循环软流水，使不同次循环并行起来,循环间有依赖 do-across 也可以从软流水获益
		寄存器分配 寄存器冲突，奇数次和偶数次使用不同寄存器(使用不同的资源解除依赖)
		循环吞吐量 = 1/不同循环启动间隔，软件流水的目标是使循环启动间隔最小化
		资源约束
			R=[r1,r2...],ri可用资源，一次迭代使用ni个资源则启动间隔 T = max {... ni/ri...}，若T<1,则将循环展开可获得收益
			选择稳态时连续启动的几个循环，组合它们T个时刻的资源使用，T个时刻的资源都可以被满足，则无资源冲突
		数据依赖
			n1->n2<@,d>,第i次迭代中的运算n2，必须在第i-@次迭代的运算n1执行d个时钟后才可执行,T为启动间隔 =>
			S为调度方案,S(n)代表第i此迭代的运算n在此次迭代的第几个时刻运行
			n1执行时刻 t1 = (i-@) * T + S(n1)
			n2执行时刻 t2 = (i)* T + S(n2)
			n2必须在n1执行d个时钟后执行=> t2-t1>=d => @*T +S(n2) -S(n1) >=d 
										  =>  T  >= [d - (S(n2) - S(n1))] / @ 
										        令T = d / @ 满足上述约束
										        存在数据依赖环则启动间隔不小于延时总数/迭代距离之和							        							        
		min T #求T是一个整数规划问题
		s.t.
			资源约束  T >= max {... ni/ri...} all资源
			在数据依赖 T >= max {dj /@j } all环
		启发式求解方法 从约束得到T的下界T0 ->从T0开始搜索调度方案
		mod变量扩展* #pingpang
			某变量仅在循环内使用则变量是可私有化的，此变量可转化为一个数组，第i次循环读写第i个元素 #cuda
			if reg 生命周期为l，启动间隔为T,则一个时间点q=floor(l/T)是活跃的，分配q个寄存器，第i此迭代使用第i%q个寄存器
			指令条数会可能被扩增q倍，因为要使用不同的reg
		带断言的指令可以将控制依赖转换数据依赖*
		
并行与数据局部性
	数据局部性代表了低通信开销，好的缓存命中
	时间局部性 一个数据短时间被多次使用
	空间局部性 相近数据在短时间内使用	
	#任务层次并行 适合使用任务图，拓扑排序，同一层次无依赖任务可并行
	仿射变换
		迭代和数据访问关系
		迭代如何分配给处理器
	例子～矩阵乘
		Z = X * Y
		分块划分矩阵，每次处理一个小块可以将小块尽量缓存，提高cache hit，不同的块还可以划分到不同core上并行
	迭代空间I
		d嵌套迭代，构成d维迭代空间
		符号常量 在嵌套循环中值不变的变量
		从原循环中下标的上下界构成一个凸多面体迭代集合，在这个集合内只有遵循数据依赖关系可以按照任意顺序迭代(数据依赖约束)*
		#如何选择一个遵循数据依赖关系又能优化局部下和并行性的顺序?
		投影 
			d维空间多面体，投影到除第i个维度的其它维度，生成一个d-1维度的多面体，则消除了第i个维度
			消除xi算法
				L <= c1xi  -> c2L <= c2c2xi <= c1U -> c2L <= c1U 
				c2xi <= U		
				新的约束c2L <= c1U 从中消除了xi
		坐标轴变换*
	数组下标
		仿射函数f: 迭代下标 -> 数组下标
		根据映射可寻找哪些迭代访问访问的是同一个/相同cache line的数据
		数据复用
			同一个元素的复用
				i和i'是两次迭代的迭代向量，若指向同一个数组元素则
				Fi+f = Fi'+f => F(i - i') = 0
				若F满秩则具有唯一解 i-i' =0，i'是i自身同一个迭代
				若F不满秩则欠约束，具有多个解，说明存在多个不同的迭代指向同一个元素
			同一行元素的复用(空间局部性,假设按行存储并一行可存储在一个cache line)
				删除F矩阵的最后一行，即可求解同一行元素复用
			组复用
				Fi1 + f1 = Fi2 +f2
				F(i1-i2)=(f2-f1)
		数据依赖
			读是独立的，不同位置访问是独立的
			两个不同的静态访问满足Fi + f = F'i'+f'，且有一个写运算则依赖
			整数线性规划问题 
				数据依赖访问 等式约束 
				循环界限     不等式约束
				解:
				1)GCD测试，是否存在满足等式解，若存在才存在数据依赖,将等式应用替换，只保留不等式
					a1x1+a2x2+...anxn = c，有整数解，当且仅当c % gcd(a1,a2,...an) == 0
					gcd(a1,a2) = c,递归计算gcd(c,a3,a4,...)*
				2)求解不等式
					简单不等式有一些简单的求解技术优先使用
					记忆模式 某些访问模式频繁出现，避免重复求解它的数据依赖关系,求解后记录到表格中
					分支定界
						1.先看作线性规划，判定是否存在有理数解
						2.证明是否存在整数解
						3.分支定界,递归求解子问题
	无同步(通信)并行
		可并行化循环
			可并行化循环不同迭代间不存在数据依赖
			P = CI + c ,将迭代I={i,j,k,...},映射到处理器P={p0,p1,p2,...}
			假设有多少个可并行化的循环就有多少虚拟处理器，P向量索引了虚拟处理器阵列中的唯一一个虚拟处理器
			#虚拟处理器是虚拟化的资源，映射到相同物理cpu上的虚拟处理器处理的任务是并发的，不同的物理cpu是并行的
		空间划分约束 
			要求无core通信，因此所有有数据依赖的op必须划到相同的core上
			对于任意Fi1 + f1 = Fi2 +f2 => C1i1 + c1 = C2i2 + c2 #空间划分约束 
		rank(C)
			对于迭代深度为3的循环I={i,j,k}
			rank(C) = 3,I划分到不同core
			rank(C) = 2,{i,j}划分到不同core,不同的k划分到相同的core,最内层循环不能并行
			rank(C) = 1,i划分到不同core,不同的{j,k}在一个core,只有最外层循环可并行
			rank(C) = 0,所有I在同一个core，无并行
		代码生成
			|P|个core上执行迭代I
			parallel for pid in |P|:
				for I:
					if pid == C1i1 + c1: #语句1的仿射划分 
						exec  S1;    #语句1
					if pid == C2i2 + c2;  #语句2的仿射划分 
						exec S2;    #语句2
			优化
				1.根据i,j和pid的关系以及i与j的循环上下界,收紧pid的循环范围
				2.针对内循环，将语句划分到不同迭代子空间，同一个迭代子空间应用相同的if测试条件，消除/减少if测试
	同步
		对原程序裂变，寻找如果加入同步可获得并行性的可能
		PDG 
			node是赋值语句，寻找数据依赖，寻找语句s1的实例i1(s1)和语句s2的实例i2(s2)的依赖关系，构建一条边
			PDG中一个环连接的语句不可分割裂变,s1<->s2也是环
			单向的s1->s2可分裂，分裂到不同循环，前后插入sync保序，不同循环可并行
		代码生成
			1.构造依赖图PDG,划分强连通分量(每个节点都能到达分量中其它所有节点)
			2.对强连通分量(SCC)拓扑排序，必要时裂变
			3.每个SCC寻找无同步并行性，在并行化SCC前后插入sync
	任务流水线化并行
		任务分解为不同阶段，每个阶段分给不同core
		两层询循环，内循环分解为不同阶段 #单core下就是内循环展
		内循环流水线化需要在不同外循环之间插入同步*
		完全可交换循环 
			内外循环可交换时
			考察交换循环有收益时则可交换循环(数据局部性、可流水线化等)
		执行序列的变化
			执行序列A->执行序列B，数据依赖关系不变
			循环被流水化，则循环内运算执行序列被重排到不同的迭代(不同的迭代就是不同的阶段/时间步)
			时间分划约束
				语句s1和s2在迭代中的实例存在数据依赖
				i1(s1) -> i2(s2) => Fi1 + f1 = Fi2 + f2 =>C1i1 + c1 <= C2i2 +i2 #时间分划映射语句实例到时间步
		局部性优化
			仿射分划将依赖运算划在一起，提高了时间局部性
			数组收缩
				多个迭代使用数组相同位置，则使用一个标量存储，多个迭代访问同一个标量
				归约为标量使用寄存器存储，速度更快
			分块
				提供内循环局部性
				内循环数据复用，内循环过大时不利于复用，对外循环分块，创造一个小的有明确界限的内循环
				for i in [0-n] => for ii = 0 ; ii < n; ii+=4
									for(i=ii; i <min(n,ii+4); i++) 
	其它应用
		分布式 在数据可用时，立即发送，在需要数据时才等待
		多指令发送CPU
			外层循环可并行，内层循环不可并行时交换内外层循环使内层可并行获得更好的指令级并行
		SIMD
			具有gather/scatter的元素不要求连续，可以使用同一个index索引
			对齐要求，一般会有代码处理边界
		数据预取指令 预取到cache

过程间分析
	好处
		所有代码在在编译时可用时，编译时就可以通过分析将间接调用转换为直接调用或内联
		指针/引用别名分析 打破保守策略，精确分析找到更多优化点
		程序静态分析
	调用图	c调用p则c->p
	过程的行为和被调用的函数上下文有关,调用上下文一般通过，调用栈来定义的
	上下文无关分析
		把func的调用和返回看作goto,为参数传递和返回值增加赋值语句，构造CFG
	上下文相关分析
		精确信息可能要考虑整个调用链
		克隆 对每个感兴趣的context 生成一个方法clone，然后上下文无关分析
		利用类型匹配信息可以改进指针分析	
------------------------------------------------------
中科大-保健
代码生成
	输入 AST、SYM table
	目标机器
		mips/arm/x86/...
		jvm/*vm/...
	任务
		指令选择
		为数据分配资源
	stack计算机
		stack不考虑reg分配，生成指令非常简单
		多用于虚拟机，因为虚拟机的寄存器是内存虚拟的，虚拟寄存器和栈没有速度差别，但stack生成指令更加简单
	reg计算机
		reg速度更快
		RISC 
			仅有ld/st访问内存(mov是赋值运算是计算不是IO)，计算仅在reg中指令的执行时间可精确估计，情况单一有利于compiler优化
			#对比x86 CISC,计算指令支持一个数在寄存器一个在内存中，访存模式也更加的多，选择太多优化也更加复杂
	IR
		通过从高层IR到底层IR进行语义不变的等价变换对代码进行优化和分析，不同的IR适用于某种分析或优化
		IR框架
			定义一组对象来对程序结构进行表示，
			定义一组可支持的操作来进行程序分析和优化
		三地址码 接近risc汇编，易于代码生成
		cfg
			静态保守
			控制流分析
			数据流分析
				block内语句传递函数
					gen(si) =语句si生成的定义
					kill(si) =语句si杀死的定义 
					in(si) 能到达到si处的=定义 
					out(si) =(in(si) - kill(si)) U gen(si) #存量 -  死亡 + 新生
				基本块间 定义交汇运算，汇集来自不同前驱的到达集合
				不动点算法 迭代直到解集合不发生变化
			干扰图
				node是变量，若变量的活跃区间重叠则有一条边，代表干扰关系
				#建模问题为图，使用图算法解决问题
				图着色	颜色的数量代表使用的寄存器的数量，相邻的节点颜色不同	
		优化
			程序分析 对程序动态运行的保守近似估计
			重写
