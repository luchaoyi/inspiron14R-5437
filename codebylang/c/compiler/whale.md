Symbol Table
	storage class 
		scope
			嵌套?内层是否允许遮盖外层?
			#llvm scope symbol table 符号表内需要存储作用域的标识(例如指针/路径前缀等)，才能区分相同scope的declare confict和作用域遮盖
		visible 
		lifetime
symbol table
	<hash(k),(k,v)>
	hash + symbol stack + block stack 
		scope
			所有新加入符号表项entry(k,v)都在栈中，block stack保存了每一个scope 在stack中的基址，离开scope则清空基址之上的所有符号
			entry需要一个作用域标识来区分	相同符号是否在同一个scope冲突还是不同scope* 
		拉链
			hash(k)相同的符号头插入链接在一起，形成look up 链
		#这里通过stack 构建scope, llvm通过link list 构建scope
存储绑定
	变量名->地址，指定一种适合的寻址方法
	global / static 可重定位地址，相对基地址(e.g. pc)偏移
	栈变量 
		相对stack frame offset / 虚拟寄存器
		按照大小排序变量，将变量place 在 合适的align边界上
		数组/大对象
			place in frame, frame过大，造成offset过大           #优化用
			place frame之间，并将指针存储在frame中，间接访问 #通用
inst load/store
	sym2reg sym引用的存储位置变量存储到分配的Reg load reg, sym 
	reg2sym reg存储内容存储到sym引用的存储位置 store sym, reg 
	消除冗余ld/st	

IR
	IR设计
		level,adt,表达能力，优化适应性
		多层次IR
		为某些语法结构设计多种表示，一种表示可能适应于一种特定的优化
		二进制形式 内部集成，二次优化等
			变量 表现为指向符号表项的指针，使用相对位置，保证位置无关性
		字符形式 可阅读
		HIR
			AST	
				有足够信息可src2src，可转换回源代码或转为其它代码
				lower为低层次IR codegen	
		MIR
			四元式 (op, dst, src0, src1)
			适应多种语言和体系结构
		LIR
			与目标机器inst*基本*一一对应
	数据结构
		Procdure/Function
			name
			nblocks :the number of blocks
			ninsts: ninsts[i] is the number of block[i] insts
			base block: inst array
				针对block 需要定义一组，插入删除指令，以及产生分裂block的interface
			succ,pred:前驱和后继
Runtime	
	传参
		值传递 
			需要复制 
 			优化，COW编译器确定参数没有被修改时(只读)，可以优化为传引用
 		传地址
 			无复制，对于基本类型若无修改不建议传地址，
 			因为基本类型某些情况下直接放在寄存器(优化)，如果传地址，则强制必须有地址可能会抑制寄存器传参*
 		寄存器分类
 			特殊的
 			调用者保护的
 			被调用者保护的
	共享对象开销
		运行时链接
		位置无关代码
		数据私有副本	
auto codegen
	语法制导GG
		IR转换->模式匹配->代码生成
	附加语义制导
	tree match and dp
		树可以表示为路径字符串集合，利用自动机可以产生匹配规则
		使用dp来计算最小代价匹配

### 分析

控制流分析

​	Region CFG流图的强连通子图

​	**DFS**

​		前序 preorder  到达时间

​		后序 postorder 完成时间

​	**强连通分量(SCC)**

​		对于一个SCC,每一个包含它的SCC时它自己，则它是极大的

​		自然循环是CFG中SCC的一种类型

​	**必经节点关系**
​			entry->A->B, 从入口到达B必然经过A，A是B的必经节点， A dom B
​			自反 B是自己的必经节点  and 非对称(if A dom B and B dom A, then A = B)  and 传递 => 因此可表示为树
​			直接必经关系 A直接必经B， A idom B
​		后必经节点关系
​			P->Q->exit, P到达出口，必然经过Q，Q是P的后必经节点 Q pdom Q
​		回边	边v->w，w是v的必经节点则，边为回边
​	**自然循环**	

​			利用必经节点关系识别CFG中的自然循环

​			对于回边m->n, n和到达m不经过n的节点和边构成，n为循环首节点

​			前置节点
​				在循环首节点前插入一个新的block,初始为空，循环内外提到外面的代码会插入此基本块

​	可归约/结构良好的	
​		持续变换最终可归约为单个节点的图为可归约/结构良好的
​		没有goto到循环体内的跳转，有唯一的入口节点
​		语言中避免goto到循环体类似操作，构造出的CFG为可归约的循环结构，易于分析和优化

​	区间分析
​		流图划分为不同的区域，区域是一个抽象节点

​		将所有叶子节点(基本块)合并归约的过程可表示为控制树 (like 聚类树一样，反映了归约过程)，根节点是归约为一个节点的抽象图

​		施加固定的转换规则，归约CFG

​	？？？

​	结构分析

​			一种更精确的区间分析，对所有控制结构分类，对于源语言的每一种控制流结构给出一个规则 ，用这些规则执行数据流分析比迭代数据流分析更加有效率

​		？？？

数据流分析

​	基于控制树的数据流分析

​		bad 实现难

​		good 以增量方式随着程序优化转换更新数据流信息更容易

```
???	区间分析 or 结构分析
```

def-use 链和 use-def链是关于变量数据流信息的**稀疏表示**

SSA def-use清晰，简化了很多优化



依赖分析
	顺序依赖 S1必须在S2之前执行
	控制依赖 S2条件不满足时才执行S3                              c
	数据依赖 
		真依赖 S3给d赋值,S4使用d的值，颠倒S3和S4的顺序就会出错 t 
		反依赖 S3使用，S4赋值                                      a
 		输出依赖 S3,S4都给某变量赋值   #写冲突                   o
 		输入依赖 S3，S4都使用某变量值  #读冲突                   i
 	基本块内依赖DAG
 		block内部无control flow, 因此是无环的图
 		**结构相关** 每条指令使用资源向量标识是否用到资源/用几个资源，检查资源向量的交集可得到是否存在，资源竞争

​		**冲突** I1必须在I2之前执行才能保证正确性

依赖测试方法

???

程序依赖图PDG

​	由数据依赖图和控制依赖图组成

 	控制依赖图CDG
 			以谓词为root节点和中间节点，以非谓词为叶子节点 

​			通向叶子节点的路径上的谓词满足则叶子节点执行(决策树的感觉)

​     控制依赖关系有后向支配边界定义

​	PDG中对于CDG**控制依赖于同一父节点的的节点若没有数据依赖可以并行执行**

​	动态数据结构依赖关系

​	...

​		

别名分析
	存储位置可能通过多种途径被访问
	may分析 某条路径发生
	must分析 所有路径发生
	流敏感 考虑语句执行顺序，和控制流有关
	流不敏感 不考虑执行顺序和控制流，**不需要执行数据流分析**

​	流敏感must信息可映射为函数Alisa(p,v)  = l,在程序点p，变量v一定引用存储单元l



​	别名收集器*
​		由编译器前端提供，分析语言提供的别名机制，收集别名
​		为语句定义别名规则，根据规则生成初始别名信息(传播的根)

​		语言相关的，生成一组语言无关的别名描述，传递给传播器

​		限制语言的别名产生机制利于编译器优化，如go语言的受限指针，c++的引用

​	别名传播器 

​		语言无关的，输入的是一组语言无关的别名描述（由收集器提供）

​		执行数据流分析，传播别名关系

​	...



### 优化

目标 速度和空间(嵌入式端大小很重要)

流不敏感优化 不需要数据流分析

流敏感优化 需要数据流分析



struct标量替代

​	内存->寄存器，有利于类似复数等运算

​	增加寄存器使用，可能造成spill，降低性能

代数化简和**重结合**

​	利于数学定律将表达式划分为常量部分，循环不变部分等，以利于其它优化

​	代数变换削减计算强度

​	浮点数变换计算顺序可能是不安全的，计算顺序也会影响精度

全局值编号

​	作用在SSA IR

​	值图 

​		有向图，{nodelabel} -{edgelabel}->{nodelabel}

​		nodelabel 运算符，常数，符号

​		edgelabel 表示node的第i个操作数

```
初始化:
粗略的将nodelabel(运算符，常数，符号)相同的节点划分到一个集合
对于非叶子node,所处的集合有多个元素的集合，这些集合的node不一定重合(要看operand)，加入worklist
进一步划分:
worklist的节点，进一步根据operand划分(看operand时考虑结合律)，保证相同集合的元素是可重合的
```

复写传播

​	b<-a ,在后续a和b都没有重新赋值的区间，a可以代替b

   进一步若消去了b的所有use, 则进一步可以消除b的def

​	局部(一个)基本块内复写传播O(n)

```
ACP ={<left ,val>} pair集合
之间扫描一遍block完成
if assign 
   left = val insert pair ACP = {<left, val>}   |gen
   remove from ACP <*, left> 					|kill
if binary / unary
   copy value(oprand*, ACP)
```

 全局需要先做数据流分析，计算出ACP集合



冗余删除

​	公共子表达式删除

​	...

​	**循环不变外提**

​		循环不变指令集合

​			operand is const

​			operand的到达定值在循环外

​			operand的到达定值只有一个式循环内不变量

​		标识为循环不变的指令可移动到循环前置block

​			标识为循环不变量的def指令安全的移动到循环前置block的条件 

​				def v的语句的bb必须式循环中所有use v的bb的必经节点

​				def v的语句的bb必须是循环中所有出口基本块的必经节点 

​				#因为移动def v到循环前置block会导致def v到达所有loop内节点，以及可到达出口k

循环优化

​	归纳变量识别

​		基本归纳变量 循环内显示+/-一个常量 i+=d

​		依赖归纳变量 

​				v = b * biv + c , biv 是基本归纳变量

​				能用同一个biv表示的归纳变量是一个class ,biv为class的基

```
1. 寻找loop body基本归纳变量集合，形如i+=d
2.寻找loop body满足条件的变量j
	j在赋值左边
	j = i * e / i + e / -i; e is const,i is 基本/依赖归纳变量
	/*
		j = A * i + B
		k = C * j + D = C*(A*i+B)+D = AC*i+ BC+D 依然满足线性关系
	*/
#基于pattern匹配
```

过程优化

​	**内嵌扩展** 

​		一组特定函数名被编译器识别，这组特定函数名有模板化的高效汇编语言实现

​		开启优化时，替换函数调用为(编译器)内置的内嵌函数

​	叶调用优化

​		...



寄存器分配

...

代码调度

...

 控制流优化

/\*flower树上Ch10有消除无用控制流归纳了四种模式\*/

...

postpass / peephole优化 * 

​	机器代码已经生成后的在机器代码上移动窗口寻找模式

​    机器方言指令归并(相同效果的一条指令替换一组指令)



过程间优化

​	分析顺序

​		RPO

​		调用顺序IO 先处理该过程然后处理被调用过程

​		逆调用顺序RIO 先处理被调用过程，然后处理该过程

​	调用图

​		一种过程为其它过程参数/过程为变量/常量的调用图构造方法

​		构造，记录，传播

​	...



存储层次优化

​	cache 

​		inst / data / tlb

​		重排代码减小工作集大小

​			**过程排序** 

​				过程调用关系和使用频率排序，将子过程挨着调用过程排减少换页	

```
1.构建无向调用图，边上时调用次数
2.贪心策略 每次选择最大的调用次数边合并节点，重新计算其它边的调用次数
3.最终合并为一个节点，按照合并顺序，安排代码
```

​		过程分裂

​			获取过程内基本块执行频率，将频率高的基本块连续安排在一起，不频繁的挨着

   循环转换

​	...

