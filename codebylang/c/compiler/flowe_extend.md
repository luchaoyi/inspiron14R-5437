## 前端

### 4 上下文相关分析

**类型系统**

类型检查编译期则运行期可无类型检查并保证安全运行

生成高效代码

组件 

	基本类型
	
		bool, 数字（浮点，整数（符号?）），字符(ASCII/UNICODE)
	
	复合类型合成规则
	
	类型等价或兼容判定 
	
		名字等价
	
		结构与等价
	
	表达式类型推导规则

### 5 IR

图IR 图描述算法对象，如语法分析树，数据依赖图（此图拓扑序同一层级节点无数据依赖关系），控制依赖图

线性IR 抽象机上的伪代码表示形式

混合表达 如图表示控制流，基本块内使用线性IR表示无控制流的代码块

#mlir是混合层级且是混合形式的(线性+图（Operation能表示图，由嵌套结构））

**符号表**

理论上所有信息都可以从IR上重新计算得到，符号表只是一种存储提高效率的技巧

### 7 代码形式

编译优化器在IR上进行有限的优化，因此在生成IR结构时应该非常谨慎，生成更优的IR结构，有利于后续优化或代替优化器不能完成的优化

**关系操作硬件支持**

直接条件码 比较操作/算数运算会设置条件码寄存器，cond_br指令根据条件码跳转 // X86

条件复制 增加添加复制指令，条件码选择复制值   //mlir select r3, r2,r1

谓词执行 指令附加谓词，根据谓词决定是否执行生效 ,谓词更利于简单循环，避免了分支的开销，无效指令序列太长会抵消这种好处 //arm

**结构数组布局**

允许对结构体数组元素取地址则布局为多个布局相同的连续的结构单例 {a,b,c|a,b,c...}

不允许对结构体数组元素取地址则可以布局为成员为数组 {a..., b..., c...}

## 优化

### 8 简介

**范围**

​	局部 单个基本块内，无跳转顺序执行

​	区域方法 如一个循环，区域内的BB可组合划分为EBB进行分析

​	全局 过程内

​	全程序 过程间

**冗余** 通向p的所有路径，表达式e都进行过求值，则e在p冗余

**生命周期** 名字的生命周期介于def->use之间

**树高平衡**

​	-

**LVN**

​	Ti <- Li Opi Ri 

​	使用hash将名字，常数，表达式映射为不同的值编号

   1.查找或创建 Li值编号 VN(Li), Ri值编号VN(Ri)

 2. 构造散列键<VN(Li), Opi，(Ri)>，查找hash表，如果存在则表达式冗余,  替换为赋值操作，关联编号到Ti

 3. 否则表达式第一次计算，为它生成新的值编号，关联编号到Ti

    **交换运算**  在构造散列键时引入某种排序保证 b x a 和 a x b构造的散列键都为<VN(a), x, VN(b)> 则产生相同的值编号

     **常量合并** 在LVN中发现运算数都是常量则可以之间执行计算并记录在散列表中(扩展表)，表达式替换时常量可直接替换为立即数加载

    **代数恒等式** 代数恒等变换是编码为一系列if-else规则的，构造判断决策树识别恒等式并分配相同的值编号

**SVN**

​	作用在一个EBB上，一个EBB内包含多个BB，具有多个前驱(进入)的BB为一个EBB的开始，和其它单个前驱的互联BB形成一个EBB

​	SVN将EBB内部一条直线路径当作一个基本块应用一次LVN

​	(B0, B1)  B0应用LVN, 传递到B1,B1应用LVN

​	(B0, B2, B3) B0应用LVN,传递到B2,...

​	(B0, B2, B6)B0应用LVN, 传递到B2...

如上所示不用路径前缀相同是操作时冗余的，高效操作需要发现前缀避免冗余，重用操作, 可以使用作用域机制控制hash表

LVN和SVN作用于SSA IR上更加高效

**活动变量**

一条从p到use v的某个位置的路径上，v在此路径上没有重新def, v在位置p是活动的

初始活动变量为{}, 逆方向向上找，遇到use 激活产生一个活动变量v， 没有遇到def v则活动变量穿过此程序点，在没有被def kill之前的程序点到use位置，变量v都是活动变量，此区间是变量的活动区间

遇到def,则 穿过此程序点时v不在是活动变量，从集合中剔除

在出口n0的活跃变量，表示从n0到某个位置对变量use的位置，没有def，即这些**变量没有任何初始化就被使用**

**内联替换**

优点 直接消除调用前后代码；消除边界，提供更多上下文信息为进一步优化发现机会

缺点 增加代码长度，可能增加寄存器需求

**过程置放**

p调用q，我们希望p and q占用相邻的内存

1. 建立调用图，边的权重为估算的执行频度
2. 按照权重依次合并节点
3. 合并完成会得到一个list,  按照此list放置过程

**LTO** 

静态链接时将多个独立的编译单元整合会发现新的全局优化机会

### 9 软件分析

#### 9.1 迭代数据流分析

[0] https://blog.csdn.net/hahahaqwe123/article/details/105875141
[1] https://zhuanlan.zhihu.com/p/24338970
[2] https://www.jianshu.com/p/1fa72dc243d4

##### 9.1.1 概念

迭代数据流分析框架不适用于SSA形式的IR

**程序点**

程序执行的位置，每个程序点关联数据流值，不同程序点通过传递函数状态变换

分支通过meet/join运算汇合

数据流方程描述了数据流值沿着分析方向穿过语句时在不同程序点的变化规则

**不动点迭代**

​	初始集合，方向（-> / <-），迭代公式(传播和汇聚函数) 

​	当不动点迭代具有唯一解，求解与次序无关时可以选择遍历次序优化执行时间

**分析迭代是否会停止？**

关键词：单调，有界

首先确定数据流值在增大还是缩小(具备单调性只可能增大。缩小)？再确定是否有上/下界

迭代函数单调，且数据流有界则迭代币停止

e.g. 集合扩大还是缩小？上界是全集，下界是空集

**集合运算与位运算**

编译器可以使用位向量来编码集合，则集合运算可转换为位运算

A ∩ B 可以表示为 a&b
A ∪ B 可以表示为 a|b
A - B 可以表示为 a&~b
A △ B 可以表示为 a^b， A 和 B 的对称差表示属于A而不属于B

**集合上的二元关系**

自反?，对称?，传递?

自反

​	对于任意x属于A，满足xRx则A上的关系R是自反的，否则是反自反的

​	e.g. 小于关系是反自反的，小于等于关系是自反的

**偏序集**

R是自反的、**反对称**的和可传递的，则称R是集合A的偏序关系，简称[偏序](https://baike.baidu.com/item/偏序/2439087)，记作“≤”

集合A和偏序关系R一起称为偏序集，记作（A，≤）

**格**

```
全序，任意二元素间都能满足某种关系的排列顺序，
偏序（半序）在部分元素间的能满足某种关系的排列顺序

<P, ≤>是一个偏序集合，并有Q⊆P，y∈P
上界：对任意x（x∈Q）有x≤y，则y为Q的上界，不一定唯一，注意y只是集合中的一个元素
下界：对任意x（x∈Q）有y≤x，则y为Q的下界，不一定唯一，注意y只是集合中的一个元素
最小上界：因为上界不一定唯一，那么Q中所有的上界中最小元即为最小上界
最大下界：因为下界不一定唯一，那么Q中所有的下界中最大元即为最大下界

对P中任意元素x和y，{x，y}pair组成的集合都有最大下界和最小上界，则<P, ≤>称为格
偏序集中任意两个元素都有唯一的最大下界和最小上界那么这个偏序集合构成一个格

格第二种定义,运算满足以下四条规律的代数结构
1.同一律
2.交换律
3.结合律
4.吸收律

格的二元运算符：
x∧y: x与y最大下界 交运算 meet
x∨y: x与y最小上界  结运算 join
交和并运算可以定义值的偏序关系， x ≤ y 当且仅当x∧y = x


meet和join对P所有子集S有定义(格是两个元素pair子集，完全格是任意个元素子集)，被称为完全格(complete lattice)，join和meet只定义一个的代数结构被称作半格，完全格有全局最大值top和全局最小值bottom

格的高度 偏序图中任意两个结点的最大距离+1

```

**格与迭代数据流分析**

```
数据流迭代分析可以表示为(D,L,F)
D 方向
L 格建模则数据流值为格值，L是有界的
F 变换函数L->L, 由两部分组成
	传递函数f: L->L
	meet函数:L x L -> L
	F满足单调性-> f和meet满足满足单调性
MOP界
	求解数据流方程时想要计算的值是满足全路径的解（**理想解**），只能保证流函数是单调的任意数据流问题可能不存在MOP	
MFP 
	最小/大不动点，迭代法求解的结果，从top/bottom元素初始，在迭代中F单调变换，格值下降或上调首次发现的不动点即为最小/大不动点
	如果F是可分配的即满足分配律(F(x⊔y)=F(x)⊔F(y)),则MFP == MOP
```

##### 9.1.2 访问顺序

[0] 算法导论

[1] https://blog.csdn.net/dashuniuniu/article/details/52159792

数据流迭代过程节点的访问顺序不同，效率也大不相同

对于前向数据问题（foward-analysis）来讲，逆后序（Reverse Postordering）非常高效

逆后续访问节点之前会尽可能的多地访问前驱节点，=>对于后向数据问题，在反向CFG上按逆后序效率更高

**dfs边的分类**

树边：初始访问的边，构成了dfs tree

回边/后向边/饭组边：，s->t ， t灰色，t初次访问时间小于s ,因此t是s的祖先

前向边： s->t , t黑色，s灰色，s初次访问时间小于t

横向边:  s->t, t黑色，s灰色和，s初次访问时间大于t完成时间，即t的一团已经完成了而s还没开始访问，因此不是同一团访问

**逆后序**

cfg图上的前序，后序，逆后序是对节点的一种排序order序号， 是按dfs访问时依据访问时间规定的一种顺序

preorder: 按first visit 时间排序，涂灰色的时间 

postorder：按last visit 时间排序，涂黑色的时间，涂黑色时节点的子节点已经访问完，按postorder编号顺序会尽可能先访问后继节点在访问前驱节点

reverse postorder: postorder相反的顺序，编号为|N| - postorder  #龙书上的深度优先排序就是RPO

逆后序能让依赖节点尽可能早的被访问，对于有向无环图dag，逆后序就是一种拓扑序

有环图不能拓扑排序

祖先关系 **存在节点A和B，A前序编号 >= B前序编号，A后序编号<= B后序编号，则B是A的祖先** , llvm 的 dom tree 利用此关系判定两个节点是否存在支配关系

```
  // Return true if this node is dominated by other. Use this only if DFS info
  // is valid.
  // 涂灰色时间早，涂黑色时间迟则A是B的祖先，B dom by A， A dom B
  bool DominatedBy(const DomTreeNodeBase *other) const {
    return this->DFSNumIn >= other->DFSNumIn &&
           this->DFSNumOut <= other->DFSNumOut;
  }
```

##### 9.1.3 应用

**支配** 

​	bi >> bj, 表示从b0->bj必然经过bi ，b0->bi->bj

​	init = {各节点支配自己}， -> , merge = {前驱节点交集}

​	must分析必然经过，所有路径 

​	逆后续遍历更高效

**到达定值**

定值语句d可以到达程序点p,则d属于p的到达定值集合，记作d属于RD(p)，数据流值为RD(*)

gen(B): 此基本块的定值语句，由此块gen

kill(B): 在此基本块的定值语句，会kill CFG中其它所有位置对相同变量定值的语句

in(B) = + {out(P...), P...是所有前驱}， meet运算是并运算

out(B) = gen(B) +(in(B) - kill(B))

may分析只要存在一条路径定值就可能到达

**活动变量分析**	 

如果变量v属于程序点p的活跃变量集合， 记作v属于LV(p)，表示从p到出口点的路径的某个程序点存在对变量v的use，且不存在对v的redefine，数据流值是变量的集合

若v属于LV(p)，v属于LV(q),则p->q是v的一段活跃区间

use 会在位置激活变量(又成为活动变量的生成gen)

def 会在位置kill活动变量

init  = 扫描基本快的use and def语句，生成基本块内的gen和kill集合 ; <- 

LiveOut(m)   块的出口活跃变量集合 

Gen(m) 此块激活的变量集合

Kill(m) 此块杀死的变量集合 

LiveIn(m) = LiveOut(m) - Kill(m)  + Gen(m) 在块m入口处活跃的变量集合为去掉杀死的加入新生成的 

LiveOut(n) = + [LiveIn(n的所有前驱块...)] ， +即求并集

根据所有变量在所有点是否在活跃集合中，可以得出区间(两个点之间)某变量的活跃性，和某区间保持活跃的变量集合

**可用表达式**

数据流值是cfg中的表达式集合，表达式求值到程序点p的所有路径操作数没有重新定值

must分析, 方向->, meet is交

#### 9.2 SSA

##### 9.2.1 Dominator Tree 计算方法

[0] https://blog.csdn.net/dashuniuniu/article/details/103462147

**支配者树** 直接支配节点是唯一的，因此根据此关系可构建一颗树

**支配边界**

每一个节点b有一个(被)支配集合dom(b), 任意a属于dom(b)，则a支配b（b被a支配）

每一个节点a有一个支配边界集合df(a)，即节点a不能支配的节点

对于有多个前驱的交互节点c，对于c的任意前驱d，若c属于df(d)则c需要place phi节点 

**关键边** src->dst 边的src节点有多个后继节点，边的dst节点有多个前驱节点

**迭代支配树计算方法**

```
**支配性**
从入口到节点j必然经过i, i支配j (i dom j)
entry->i->j
节点的j的被支配集合dom(j)中直接支配节点只有一个，支配树是表示直接支配关系的树i->j 则i idom j, 记作i = idom(j)，i是j在支配者树的前驱 

**后向支配性**
从节点i到出口都经过j，则j后向支配i (j post dom i )
i->j->exit
在反向cfg上使用支配相关算法可求解后向支配
```

从节点的支配者树向上回溯可得到所有支配节点，因此此算法的思想是使用idom节点作为dom集合的代表

在dom集合域 支配集迭代法的交汇运算是对各前驱节点的dom集合求交集 <=>

对应在idom节点域，是求解求交的dom集合在支配树对应的idom节点的公共前缀，结果以公共前缀的最后一个idom节点表示（若按从指定节点到根节点次序，则是最长公共后缀的第一个节点）

**Lengauer-Tarjan Algorithm** 

支配 对g中的任意点w，若存在d，去掉点d无法到达w则d支配w，起点以外的点都有两个**平凡的支配点**，一个是自己，一个是起点

最近支配点 (idom定义)

​	w的支配集中，i != w ，且i被dom(w)中所有非平凡支配点支配则i为w的最近支配点 , i = idom(w), idom(w)是唯一的

​	证明 支配具有传递性，支配关系是一种全序关系，因此存在“最小”的元素

前序编号

​	前序深度优先遍历CFG g（按first visit 时间排序，涂灰色的时间），对Node编号

​	树边总是由编号小的指向编号大， 前向边总是由编号小的指向编号大

​	后向边总是编号由大指向小, 横叉边编号也总是由大指向小

半支配 semi dominator

​		存在一个点y，从y出发有一条到x的路径，并且路径上任何一点z（不包括x 和y ）都满足dfn(z) > dfn(x),则y为x的半支配点，记sdom(x)为dfn最小的半支配点

​	删除原图中的非树边后，连边( sdom( x ) , x )不改变原图中的支配点关系

​	可看作是对idom的一种逼近

Rule

```
V代表图的点集，E代表图的边集
　　a→b代表从点a直接经过一条边到达点b，
　　a⇝b代表从点a经过某条路径到达点b，
　　a→˙b代表从点a经过DFS树上的树边组成的路径到达点b（a是b在DFS树上的祖先），
　　a→+b代表a→˙b且a≠b;
<引理>　
1.对于任意w≠r，有idom(w)→+w
proof:
	否则，不存在树边组成的路径到达w =>
		idom(w)不能到达w
		存在一条路径不经过idom(w)就到达了w
		idom(w)到w有路径但不是非树边，说明存在一条树边路径不经过idom(w)就先到达了w
	以上情况都不符合idom的定义，因此idom(w)到w必定存在树边路径
2.对于任意w≠r，有sdom(w)→+w
proof:
	sdom(w)一定是w的dfs树上的真祖先，否则sdom(w)和w在不同dfs子树则所有sdom(w)到w的路径会经过sdom(w)和w的一个公共祖先，公共祖先的编号一定小于w，和sdom定义矛盾
3. 对于任意w≠r，有idom(w)→˙sdom(w)
proof:
	否则:
		idom(w)不能到达sdom(w)，根据idom(w)定义，任意到达w的路径都经过idom(w)，sdom(w)⇝w,idom(w)不能到达sdom(w)与定义矛盾
		存在一条路径不经过idom(w)就到达sdom(w),按照sdom的定义sdom(w)⇝w,因此存在一条路径不经过idom(w)就到达，与idom定义矛盾
		idom(w)能到达sdom(w)非树边路径，说明存在一条树边路径不经过idom(w)就先到达了sdom(w)
4.　对于满足v→˙w的点v,w，v→˙idom(w)或idom(w)→˙idom(v)
proof:
	v→˙idom(w) →+ w
	idom(w)→˙idom(v) →+ v →˙w

<定理|idom和som关系>
5.对于任意w≠r，如果所有满足sdom(w)→+u→˙w的u也满足sdom(u)≥sdom(w)，那么idom(w)=sdom(w)
						sdom(w)→˙sdom(u)→+u→˙w #树边组成的路径编号由小到大
proof:
	由引理4得idom(w)→˙sdom(w)，因此若能证明sdom(w)支配w则sdom(w)必定为最近支配点
	任意从r到w的路径， 取最后一个编号小于sdom(w)的x(sdom(w) > x) =>
	r ⇝ x⇝ sdom(w)→˙sdom(u)→+u→˙w
	x必定有个后继y满足sdom(w)→˙y→˙w （否则x is sdom(w)），取编号最小的y
	
	即 r ⇝ x⇝ sdom(w)→˙y→˙w
	sdom(w)→˙y 根据引理2 sdom(y)→+ y => sdom(y)≥sdom(w) or sdom(w)→˙sdom(y)→+y
    
	如果 y不是sdom(w)，则x不可能是sdom(y), 因此x到y的路径上一定有一个v满足x→+v→+y
	因为x是最后一个编号小于sdom(w)的，因此有sdom(w)→˙v→˙w
	
	x→+v→+y且sdom(w)→˙v→˙w, 说明存在sdom(w)→˙v→˙w且 v < y
	这与满足sdom(w)→˙y→˙w此关系,y是编号最小的矛盾，因此y只能为sdom(w)
	因此任意路径必然经过sdom(w)
	
6. 　对于任意w≠r，令u为所有满足sdom(w)→+u→˙w的u中sdom(u)最小的一个，那么 sdom(u)≤sdom(w)⇒idom(w)=idom(u)。
					sdom(u)→˙sdom(w)→+u→˙w
<推论>
7. w≠r，令u为所有满足sdom(w)→+u→˙w的u中sdom(u)最小的一个，有
	idom(w) = sdom(w) sdom(u)=sdom(w) 
	idom(w) = idom(u)sdom(u)<sdom(w)
	这里一定有sdom(u)≤sdom(w)，因为w也是u的候选
8.对于任意w≠r，sdom(w)=min({v|(v,w)∈E,v<w}∪{sdom(u)|u>w,∃(v,w)∈E,u→˙v})
	sdom的一个替代定义，更加高效的求sdom
```

算法步骤

　　1、初始化、跑一遍DFS得到DFS树和标号
　　2、根据（8.）按标号从大到小求sdom
　　3、通过(7.)求出所有能确定的idom，剩下的点记录下和哪些点的idom是相同的
　　4、按照标号从小到大再跑一次，得到所有点的idom，根据关系传播步骤3的计算

**semi-nca**

```
Lemma 1: 对于任意节点w, sdom(w)和 dfs tree中的父节点parntT(w)在 dom tree中的nca为idom(w)
1. 创建DFS Tree T
2. 计算所有顶点的sdom
3. init Dom tree D with r as root
4. for w in V - {r} in preorder by the dfs {
	/*
		在dom tree D中，沿着从root r到parntT(w)的路径中，第一个x<=sdom(w)的点为
		sdom(w)和parntT(w)的最近公共祖先(NCA)
	*/
	idom(w) = NCA (sdom(w), parntT(w))
	add edge idom(w)-w in D, idom(w) is parent node for w
}
```

**并查集与带权并查集**

[0] https://zhuanlan.zhihu.com/p/93647900/

[1]https://blog.csdn.net/yjr3426619/article/details/82315133

并查集管理一系列不相交的集合，并支持两种操作：
	合并（union）：把两个不相交的集合合并为一个集合
	查询（find）：查询两个元素是否在同一个集合中

树结构根节点相同表示相同集合，子节点指向根节点

路径压缩 合并可能导致路径过长(树过高)，增加查询时间，因此查询的过程当中把沿途的每个节点的父节点都设为根节点，下次查询则更容易

合并时倾向将简单的合并到复杂的，复杂度度量?(高度，节点数，面向问题自定义...)

带权并查集时多指向父节点的边上有权值，权值含义取决于实际场景，因此在路径压缩和合并时需要重新计算被操作节点的权值

**支配树在垃圾回收的应用**

java对象之间的引用关系可构造有向图，构造此dag的支配树对象A的子树（被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。

- 浅堆表示一个对象结构所占用的内存大小
- 深堆表示一个对象被gc回收后，可真实释放的内存大小

因此若对象A被gc ,则A的深堆也应该被gc

##### 9.2.2 SSA

**最小SSA**

1.求解支配树

2.求解支配边界

3.若交汇节点为多个前驱节点的支配边界则插入phi, (所有变量)

4.重命名

**剪枝SSA**

插入变量活跃性判断，避免插入死亡phi函数，构造过程必须计算LiveOut集合

**半剪枝SSA**

只在单个基本块内活跃的的变量不需要place phi，跨多个基本块的活动的变量集合称为全局名字，在全局名字被定值的节点的支配边界节点place phi，此方法可缩减部分phi函数，但不需要计算LiveOut集合

**SSCP**

一个ssa的名字可能值的集合形成一个交半格，对于常量传播问题定义的半格元素规则如下

```
交运算 ^
底元素 B , B ^ x = B
顶元素 T , T v x = x
ci ^ cj = ci ,if ci = cj
ci ^ cj = B if ci != cj
```

根据运算规则可得出，顶元素代表有可能，底元素代表完全不可能，ci代表具体常量，当一个名字被不同常量定值，则不会是常变量因此交运算会得到底元素

#### 9.3 **过程间分析**

**CHA**

方法简单，速度快，仅看方法签名和类型继承关系，**不看控制流，数据流等信息**

不精确，多用于IDE

```
Dispatch(class c, method m) {
	if  m is a method of class c and m is not abstract method:
		return m
	else
		c' = superclass(c)
		Dispacth(c', m);
}

Resoleve(cs) // cs is call site
	T = {}
	m = method signature at cs // 标识方法
	// cs时哪种调用类型，不具有多态的调用方法是明确的
	if cs is static call 
		T = {m}
	if cs is special call //构造函数等, 无多态性
		c_m = class type of m, 
        T = {Dispatch(c_m, m)} 
    if cs is virtual call
    	c = 接受对象声明类型
    	for c' in {subclass of c, c}  // 静态分析动态保守估计，因此将所有可能性加入
        	T.append(Dispatch(c', m))
     return T
     
// 一个简单的遍历搜索算法，根据Resoleve来生成新的边来构造调用图
BuildCallGraph(m_entry)
	WL = {m_entry} //work list
	CG={}  // call graph
	RM={} //可达方法集合，避免重复分析
	While WL is not empty
		m = WL.pop()
		if m not in RM
			RM.append(m)
			for call site cs in m
				T = Resoleve(cs)
				for m' in T
					CG.append(cs->m')
					WL.append(m')
	return CG
```

**ICFG**

根据调用图添加 call edge 和 return edge, 将过程内的一系列cfgs链接起来

```
call site -> call edge
| call to retuen edge 
return site <- return edge

call to retuen edge 传递不沿函数调用传递的数据流状态，即不是所有local变量都沿着call edge传播到另一个函数，传参是有限的，返回值是有限的
如果没有call to return edge 则很多和另一个函数无关的数据流状态要附加在edge上，并在另一个函数内持续传递，这些都是对被调用函数无用的信息
```

**过程间数据流分析**

额外添加edge transfer函数，处理 call edge 和 return edge

过程间常量传播

​	call edge 传参

​	return edge 传返回值

### 10 标量优化

pass的选择和应用顺序对编译器优化很重要的决策(auto tune?)

**后向支配性**

从节点i到exit出口都经过j，则j后向支配i (j post dom i )

**无用代码删除**

代码计算结果没有外部效应，因此有用代码的根源从具有外部效应的代码开始，根据use-def关系执行类似垃圾回收的**标记清除**算法

标记

	每个jump指令都被认为是有用的
	仅当某个有用的Op执行依赖于（控制依赖性）branch时，相应branch指令才是有用的，当Op被标记为有用时根据控制依依赖性将有用传播给branch指令，控制依赖性可通过在反向CFG上计算支配边界得到（RDF）

清除

	未标记的branch指令会替换为jump，jump到第一个包含有用指令的后向支配者(有用必经节点，向上遍历后向支配者树得到)
	其它非jump未标记指令被删除

**消除无用控制流**

其它pass变换得到(如 **无用代码删除**)会产生无用控制流

Clean方法RPO后根遍历方法迭代应用四种归纳的模式(**模式匹配**)直到CFG不在改变，以RPO后根遍历方法迭代可在处理Bi之前优化Bi的后继节点，提高效率

无用代码消除和无用控制流消除的**组合多次迭代可以消除空循环**

**消除不可达代码**

原因

	没有路径不可达 ~ 此情况可以使用简单标记清除，从入口开始可达的cfg节点被标记未可达，未标记的节点不可达
	有路径，但受控分支条件被推导为false ~ 此情况需要对控制指令的表达式推断结果
**代码移动**

LCM 

​	表达式的计算尽可能靠后(靠近使用的位置), 可以降低值的生命周期(降低了它使用寄存器的时间)

​	完全冗余 到达B的所有路径e已经被求值，且其后运算分量没有重新def

​	部分冗余 LCM算法会**试图在流图中放置e的拷贝，让它变为完全冗余的**

​	可用表达式

​		从入口到p所有，表达式e = lhs op rhs 已经求值过且其操作数没有没有被重新定值，e在p可用

​		正向数据流问题

​			DEExpr(m) 向下展示表达式，**DE向下展示表示正向数据流分析**，block m内的表达式到block m结束位置没有被操作数重新定值，表示block m内生成的表达式

​			ExprKill(m) m内因def求值杀死的表达式

​			AvailIn(m) m入口传递进入的可用表达式

​			AvailIn(n) = 所有前驱m的交集 {DEExpr(m) +AvailIn(m)-ExprKill(m)} 

​	可预测表达式

​		每条离开b的路径都对e进行求值，并在后续使用它

​		在b的末尾对e求值结果与沿任一路径回溯到e第一次求值的结果相同

​		即e在b中的一次求值，可预测所有代码路径的任一后续求值

​		UEExpr(m) **UE向上展示反向问题** m中引用到的表达式

​		ExprKill(m) m中def的表达式，表达式被def 造成前置位置的求值，不能再后置位置继续使用，引起了变化 

​		AntOut(n) = 所有后继m的交集{	UEExpr(m +	AntOut(m) - ExprKill(m) } 

```
LCM 移动的是表达式求值
1. 计算可用表达式Availout集合，若表达式e属于AvilOut(b)（e在b的出口位置可用从入口到b末尾e求值结果不变）则e可放在b的末尾
借助Availout信息，可判断将e向前能移动多远
从原始位置到能向前移动的最远位置中，哪个位置最好的?
2. 计算可预测表达式，计算AntIn和Antout集合（块入口和出口）；若x属于Antout(b)则x可放在b的末尾
3. 将表达式先移动到边上(i-j,i的出口j的入口)，推迟具体的放置决策：
	放置i的末尾，j的起始，或插入一个block放置e
	Earliest(i,j)满足以下条件：
    	e属于AntIn(j), 可以将e移动到块j的起始处
    	e不属于AntOut(i), e不能移动到i中
    	e属于ExprKill(i), e从j向前挪动不能穿过i, 因此i中有对e的操作数定值
    	e不属于AvailOut(i)，i此前对e的求值不可用，即i之后必须对e求值一次，即i-j边上的e求值不冗余
    	
4. 计算延迟置放位置LaterIn
5. 根据LaterIn 计算insert和delete后重写代码
```

代码提升

​	若e属于AntOut(b),在b中插入e的求值，意味着在b到离开b所有路径上对e的第一次求值冗余（删除）

​	将e的求值从b后程序点提升到了b中

**过程调用低效性特化**

X86 p调用q完成过程

​	保存p状态 (push一堆寄存器)

​	传参一堆push变量

​	call 保存返回位置

​	保存push bp , sp- >bp, 参数和局部变量以bp指向位置为界

​	sp抬升创建局部变量空间

---

​	执行q

----

​	返回值给eax

​	sp下降，释放局部变量空间，pop bp，恢复bp

​	恢复状态

**尾调用优化**

​	p call q， q位于p最后一条

​	保存和恢复p状态的一些代码可优化，并直接返回更顶层

**冗余消除**

证明两个值表达式相等，来避免重复计算

lvn,svn，lcm都可消除冗余计算

lvn为值分配编号可以发现值相等，lcm处理的是名字相等

DVNT	

​	沿支配树传播值编号散列表，步骤：

​		为块B建立一个作用域化散列表

​		递归处理B在dom tree上的所有子节点

​		B递归处理完成返回后才释放B作用域的散列表	// 深度优先，B的值编号散列表传播到了所有的支配节点{Dom(B) - B}

**辅助性变换pass** 对代码进行了变换，没有直接获得好处，为进一步优化提供了发现机会

**稀疏条件常量传播(SCCP)**

​	在ssa图上传播值信息，为条件分支依赖的操作数分配一个格值， ci 已知值，则根据值重写branch 为jump

​	在cfg图上传播可达信息

​	若常量传播和代码可达性不互相影响， 则简单常量传播 + 不可达代码消除 / 不可达代码消除 +简单常量传播 可达到SCCP相同的效果，但是SCCP处理两种优化互相依赖的情况

**强度削减**

循环中不改变的量 区域常量

随循环迭代每次常量+/-变化的 归纳变量

区域常量 字面常量 or 循环不变量 

归纳变量 SSA图的一个强连通分量 SCC（一个有向图G，对于其中任意两个顶点v,u，都存在从v到u以及从u到v的有向路径，则称G为强连通图）

OSR

-

LFTR

-

### 11 指令选择

#后端常见部件 指令选择，指令调度，寄存器分配

IR映射到目标机ISA，是一个模式匹配问题，简单方法 IR<->ISA 一对一，好一点的每个IR由多个候选序列，分情况选择更好的（指令选择的空间是规模是巨大的，没有最优解）

代码布局 block a的分支模板为b or c,执行频道更高的在内存中紧挨着更好

**树模式匹配**

-

**窥孔优化~局部模式匹配**

**搜索技术**

基于规则的模式匹配是考虑编译时效率而设计的局部最优方案，受限于提前写好模式。可以使用搜索技术发现更好的模式和指令序列

### 12 指令调度

重排指令执行顺序，试图在周期内执行更多操作（非依赖，非资源抢占可并行）

拖延/停顿 硬件互锁导致的延迟，防止对值的def在读取该值前

super scalar  单个周期内向多个单元发射不同操作，并行运行不冲突的操作

调度器调度到一个周期内执行的操作不超出硬件的指令发射能力

指令调度增加代码的重叠程度可能导致更多的寄存器需求，产生溢出，迫使操作的延迟增加

性能度量 

​	指令数/s 

​	benchmark test时间

调度 S(n) = i 表示操作n在第i个周期发射

数据流依赖关系图D

​	边表示值的流动，节点上有操作类型和延迟

​	如果n2使用了n1的结果n1->n2, S(n2) >= S(n1) + delay(n1) 

​	数据图中延迟最长的路径为**关键路径**

反相关

​	x位于y之前，y定义了x中使用的值,  y与x不能调换次序，调换导致x计算不同的值

​	没有数据流依赖，可以使用重命名技术解决

**局部表调度**

 从叶子->根前向表调度，从根->叶子后向表调度

```
基本块内的前向表调度
1. 为每个定义分配唯一的名字，重命名去除反相关
2. 建立依赖关系图D
3. 为操作指定优先级， 多个备选时有一个唯一的顺序(拓扑序不唯一)
4. 选择操作并调度
```

**调度优先级**

一般设置多个优先级，并按一定次序使用以避免平局

路径延迟为权重 优先调度关键路径上的节点

后继/后代节点的数目 被更多依赖的节点优先调度

delay 尽早调度长延迟

操作数 最后一次被使用者的数目

**区域性调度**

每个EBB看作一个基本块使用表调度，并插入补偿或抵消代码

-

**跟踪调度**

构造穿越CFG的最达长度无环路径，比EBB有更大的范围

-

**超级块复制**

汇合点限制了区域性调度和跟踪调度的可用时机，复制基本块可创造更长的没有汇合点的路径

**软件流水线**

考虑了值围绕循环流动

RC  = max u(Iu / Nu), u类型操作数目/u类型硬件功能单元数目，资源约束

DC =  max r(dr / kr)，，dr围绕递归r的累计延迟，kr是r跨越迭代的数目

​	启动间隔足够长才能使递归完成 ， 依赖关系约束

​	递归 一个基于循环的计算，在依赖图中产生了环，递归必定跨越多个迭代

-

### 13 寄存器分配

寄存器分配器的目标是有效利用目标机寄存器集合，使得load / store 指令数目(逐出代码)最小化

前调度 寄存器分配 后调度

自顶向下局部分配

​	使用最多的值应该驻留在寄存器中，统计虚拟寄存器引用次数，频度大优先**分配**Reg

​	若Vitual Reg > Reg , 则需要一般需要保留F个寄存器用于中转，因此只能使用k-F个寄存器， 按优先级为Virtual Reg 分配Reg

​	重写代码，没有分配物理寄存器的被替换为使用保留寄存器并插入load & store

自底向上局部分配

​	为VR分配R，R不足时**逐出**下一次使用处距离当前操作最远的值

​	反向遍历会得到Dist(VR)

活动范围 

​	相关的值的定义和使用形成的闭集

​	v活动的所有位置，值都必须hold

​	[i,j] i位置定义了value, j时最后一次使用，一个value的不**同活动范围可视为独立的值分配指派寄存器**，即两个不同活动范围之间不用hold value

​	活动范围创建了名字空间，是分配寄存器的基本单位，将**IR中的虚拟寄存器名字重写为活动范围名**，同一个VR使用不同的范围名，表示两次寄存器分配，即两个不同活动范围之间不用hold value

**全局寄存器分配**

发现活动范围

​	能到达一个use的所有def和一个def能到达的所有use聚合为一个名字

​	SSA IR 名字定义一次，使用一次；phi node 记录了不同路径的定义到达同一个引用，phi node 的参数和定值应该属于同一个活动范围

估算逐出代价

​	地址计算	

​	内存操作

​	执行频度

建立冲突图

​	冲突 

​		两个活动范围(LRi，LRj), 其中一个在另一个定义处时活动的且二者值不同则（LRi，LRj)冲突

​		一个活动范围LRi表示变量i的活跃区间，若变量j的区间内LRj，i活动则变量i和j不能使用一个寄存器，因此有冲突（一个活动区间分配一个寄存器，活动区间有重叠会导致冲突）

冲突图 节点表示活动范围，边(i,j)标明LRi和LRj无法共享同一个寄存器

**着色**

若LRi度数 >=k则LRi时受限的，不受限节点总是可以轻易着色

top->bottom着色

​	节点为活动范围，为节点确定一个优先级，按优先级顺序着色；记录邻居的颜色，来判定节点self是否还有颜色可用；无色可用则调用逐出或拆分机制处理此活动范围

​	逐出LRi需要在每个定义前插入store，每个使用前插入load

​	拆分活动范围 chow着色器将未着色活动范围拆分未单程块内活动范围，统计分解形成的活动范围的冲突，合并相邻程序块活动范围(如果合并后仍然不受限则可以合并)，每个拆分处活动范围起始插入load，活动末尾插入store操作 ，仍然未能着色的使用逐出

bottom->top着色

​	将节点小于k的优先入栈，所有节点入栈后重建冲突图I, 并着色

​	不能着色的，逐出或拆分



​	

​	

​	













