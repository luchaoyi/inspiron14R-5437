### 前端

**词法分析**

​	语言 给定字母表上的由穷序列集合

​	regexpr运算符

```
基本 *, | , concat 
扩展 ？(0-1)，+ 1-n次 {m,n} m到n次
```

​	词法模式可以使用regexpr来描述

​	regexpr -> nfa
​		基本规则 nullable和基本字母
​		归纳规则 运算符规则
​	nfa -> dfa 
​		**子集构造算法**构造dfa 多个节点集合构造为一个节点;使用于多次使用此模式
​		模拟 不转换nfa为dfa而是通过子集构造的边运行，边构造 适用于一次使用模式
​		#某些regexpr匹配的库compiler regexp应该就是直接转换为dfa，多次匹配此模式可加快速度 
​	化简dfa - 状态集合划分
​		开始包含两个集合 accept和not accept表示两个节点
​		若集合内节点有边跨越此集合，集合应该分裂
​		直到所有集合内的边都连接集合内的节点
​	直接reg expr构造dfa 
​		(r)# -> ast 构造正则表达式的ast
​		计算ast每个节点的last,first,null -> follow
​		根据last,first,null，follow计算state和trans rule构造dfa



**语法分析**
	#为文法附加动作可以增强文法的能力不一定使用更复杂文法
	消除歧义
		消除左递归
		提取左公因子 将决策延迟了

​	first(alpha)集合 alpha能推导的串的受终结符集合

​	follow(A)集合 某些句型中紧跟A的右边非终结符号集合 

​	LL(1) / 递归下降语法分析
​		通过first和follow集合构造选择集合 

```
对于A->alpha, 当下一个符号是a时
	当alpha不能推导未空, select集合=First(alpha)
	当alpha能推导为空， select集合 = First(alpha) U Follow(A)
```

​		递归下降/表驱动分析
​	LR文法
​		LR(0) .扩展文法构造项目集和DFA
​		SLR(1) 
​			LR(0) + follow集合
​			看当前一个符号和 follow集合消除移入归约冲突
​		LR(1)			
​			扩展LR(0),在项目集增加展望符，具体到一个符号而不是符合集合(follow集合)
​			不使用follow集合，follow集合提供的信息太泛
​		LALR
​			LR(1)的项目集太大,状态太多
​			方法1
​				构造LR(1)项集，合并核心项目集
​				例
​					假设LR(1)有两个状态,识别语言c*dc*d
​					C->d. c/d s1
​					C->d. $   s2
​					读入cc...cdcc...cd$
​					读入一串c后读入d,s1状态归约为C，读入第二个d，s2状态归约为C
​					s1和s2合并为s12 C->d. [c/d/$],行为和以前一致，归约C
​					合并后在合并前s2下当前符号如果是c/d则会报错，而合并后s12会归约，但是错误只是被延后了并不会消失
​					#相当于比LR(1)向后多看了一个符号	
​		移入归约冲突，当前符号不在follow集合的不能归约
​		归约归约冲突，存在二义性
​		表压缩 基于很多状态都有相同的动作，可以使用指针指向相同的动作空间复用
​		
**制导翻译 #翻译方法**
​	属性文法 
​		SSD **属性和文法符号关联，规则和产生式关联**
​		描述语义规则的文法，扩展上下文无关文法(语法规则)，为每个文法符号附加一组属性，代表与符号关联的信息,如类型、值、代码序列、符号表内容等
​		为每个产生式附加了一组语义规则(属性[值/类型等]计算，静态语义检查，符号表操作，代码生成等)，对属性进行计算和传递
​	综合属性 
​		根据子节点和自身信息计算，自下而上的传递信息
​		仅有综合属性的属性文法称为S属性文法
​	继承属性 
​		根据父节点或兄弟节点传递的信息和自身信息计算，自上而下传递信息
​		表示上下文依赖关系很方便 #扩展了上下文无关文法的表达能力		
​	A -> a
​		对产生式left的综合属性和产生式right的继承属性都必须提供计算规则，且只能使用产生式中的文法符号的属性
​		产生式left的继承属性和产生式right的综合属性不由产生式计算规则计算，由其它产生式计算或直接提供参数
​	属性计算
​		构建属性依赖图，按拓扑排序计算属性,要求依赖图无环
​		遍历语法树计算属性
​		一遍扫描(语法制导)
​			S/L属性文法一定没有环，可以在语法分析同时进行属性计算 
​			每个产生式配备语义(属性)计算规则，在语法分析同时计算语义规则(语义分析) *
​	翻译模式 
​		为属性计算规则规定次序等实现细节即语义动作
​		文法 + 语义规则 + 计算次序和实现细节(语义动作)
​			**属性文法		| 翻译模式**	
​		E->...A...
​			计算A的继承属性的动作插入到紧靠A之前的位置
​			计算产生式头E的综合属性动作放在最右端
​	递归下降分析器
​		综合属性 返回值
​		基础属性 输入参数 
​		产生式中的属性 局部变量


**中间代码生成** #语言各种结构的翻译策略
	hash vs rb tree
		hash O(1)查找速度，但有空间浪费
		rb tree O(lgn)查找速度，无空间浪费
	dag ast的变体，在生成node时检查是否已经存在
	ssa*
		ssa形式的ir主要用于机器无关的优化
		每一次赋值针对不同名字的变量
		Φ(phi)函数
			相同变量在不同控制流路径被定值，phi函数将两个定值合并起来
			if (flag) x1=-1;else x2=1;
			x3=phi(x1,x2);根据到达phi函数的=语句的不同控制流路径，phi函数返回不同参数值
			支配边界
				当节点B的直接前驱A不严格支配B在B在其直接前驱A的支配边界
				A
				 \ 
				  ->B
				 /	
				A'
				B有两个立即前驱A和A',A和A'不能严格支配B因此，B在A和A'的支配边界中，因此B应该生成Φ	
			精简的SSA 
				#全局分析
				Φ函式将控制流浓缩为赋值，通过对定值变量的活跃分析，来决定是否有必要生成Φ函式
				在插入Φ函式的阶段，使用活跃分析来决定Φ函式是否需要，原始变数名称在Φ函式插入点内已经不再使用，则Φ函式将不会被插入
			半精简的 SSA 
				#基本块内活跃分析
				试图减少Φ函式的数量，而不承担高成本的运算活跃变数资讯
				基于以下的观察：如果一个变数从未活跃于一个基本的区块，它就不需要一个Φ函式
	类型
		编译时名字只能分配一个相对地址offset
		类型等价 名字等价/结构等价
		类型转换
				可以在三地址代码中的运算符中带上类型信息，如在中间代码区分浮点运算和整型运算int+、real+、=int2real
				翻译赋值语句时可以进行类型转换和类型检查
		类型推导
			若t为类型表达式，S为一个对t的类型变量的一个置换，S(t)为实例
			例：
				t is T[5]类型表达式, S将t中的类型变量T置换为int, S(t)  is int[5]
			类型表达式t1和t2,如果S(t1) = S(t2)则S是一个合一置换

布尔表达式
	计算逻辑值 c = a op b,真的有op运算，按算术表达式翻译
	改变控制流 if( a op b),可能直接生成goto代码，不计算op
	短路运算
		f1 op f2,
		短路运算会使f2没有被执行,如果函数有副作用则可能产生不符合预期的结果
	一遍扫描翻译为四元式
		产生四元式时，转移地址可能无法确定，需要后面更大语法单位出现时才回填
		将待回填的地址分为两类连接为链，E.truelist和E.falselist代表了需要回填为真和假出口的地址
		需要回填的位置可以临时复用为链表指针(union)，同一个链表的需要回填地址相同



**运行时刻环境**
	-
	code           （静态区大小确定）
	data|bss      (静态区大小确定)
	heap #brk 
	.so #ld
	heap #mmap
	stack
	-
	类型决定存储大小，内存布局有对齐要求(pad)
	stack和heap安排在两端，从两端向中间分配可以更大化的利用内存*
	**stack frame**

​		-

​				<-sp
​		临时变量       
​		局部变量       
​				<-bp
​		机器状态寄存器
​		访问链
​		控制链
​		返回地址
​		传入参数 
​		-
​	变长数组的栈上分配
​		int a[size];
​		若编译时无法确定size大小则无法在编译时为a分配空间，a是变长的
​		因此在frame中仅保留一个固定长度的指针，指向数组实际分配的区域，分配可以在栈或堆上，但frame中仅包含指针		
​	过程调用
​		调用代码 实现过程调用过程的代码
​		返回代码 恢复状态返回调用
​		返回代码仅生成一次，调用代码生成n次，因此尽可能将操作放在被调用者的返回代码中*
​		frame原则
​			参数在被调用者记录的开始靠近调用者
​			固定长度项在中间
​			变化部分放在frame末尾
​	过程嵌套
​		一个过程能访问另一个过程的变量
​		q{
​			val x;
​			p{
​			acess(x);
​			}		
​			call p;			
​		}
​		p和q有可能是递归的
​		p的定义位置不是调用位置，根据p的的frame找到q的frame并访问q的变量，一种解决方法是访问链
​	访问链	#定义关系
​		指向上级作用域frame
​		p的访问链指针指向最近的q的frame,p的嵌套深度一定比q少1
​		访问链记录的是函数定义的嵌套关系，不是函数调用的嵌套关系,但是访问链指针是frame的一部分，在函数调用过程中设置*			
​		间接调用的访问链设置
​		q(ptrP) {
​			call *ptrP
​		}
​		p{}
​		r{
​			q(&p)
​		}
​		q不知道ptrP的信息，因此要求调用者r将函数作为参数传递时，也传递它的这个参数的访问链信息
​	显示表	#定义关系
​		维护指针数组，使d[i]指向stack中最顶的深度为i第的frame记录,以便快速查找
​	控制链 #调用关系 
​		指向调用者		
heap
​	堆管理器特性
​		空间碎片少
​		分配回收开销低
​		关注程序运行时特性，使程序运算更快,如时空局部性
​	局部性 cache和层级结构mem
​	碎片整理
​		不同的容器内容纳不同尺寸的基本内存block
​		一个内存块尽量不跨越页面
​		边界标记 
​			存储块的两端存放 free/used位标记 以及 块大小
​			每次仅查看，被回收的相邻的两个块，接合
​		链表
​			空闲块链接起来
​	常见错误
​		内存泄漏
​		悬空地址解引用
​		NULL指针解引用
​		越界访问
​	垃圾回收 ~ 开销比较大 + 可完全防止内存泄漏
​		必要信息
​			运行时需要知道对象类型(内存占用大小)
​			对象包含的其它引用对象
​			引用指向开始位置，相同对象具有相同引用
​		类型安全 ～ 任何数据分量的类型都是确定的
​			动态安全 运行时可全部确定
​			静态安全 编译时可全部确定
​			c/c++ 指针的自由操作使语言不是类型安全的，无法垃圾回收
​		开销
​			总体运行时间/内存占用/每次运行停顿时间/影响了数据放置，因尽量不影响局部性
​			引用计数引入了开销，但避免了长时间停顿(慢刀宰猪)
​		可达性
​			不需要解引用就可以访问的对象为 root set
​			某些语言是受限指针，但是编译优化是在机器码层面产生了隐藏的非受限指针操作
​			因此优化时必须考虑提供必要信息，保证垃圾回收的安全性
​			可达对象集合改变操作
​				对象分配
​				参数传递/返回
​				引用赋值
​				过程返回

​		引用计数
​			+
​				开销分摊，回收及时，停顿较短
​			-
​				循环引用
​				开销大
​				局部栈更新很频繁，因此优化考虑不对root set 引用计数
​		周期性运行，全面停顿
​			标记-清除
​			state 未分配 -> 未访问(未确定是否可达) ->未扫描(以及确定是否可达，未确定其包含的引用的对象的可达性) ->已扫描
​			标记-压缩
​				将所有可达对象重新定位到堆区的一端，使得空闲空间成为一块
​				重新定位后局部性更好
​				标记 -> 为可达对象计算新地址 ->移动可达对象并更新引用
​			copy回收
​				将空间划分为 跟踪空间和空闲空间 解除对象跟踪和发现空闲空间之间的依赖
​				标记时直接拷贝对象到to空间，直到标记完成，所有可达对象被压缩在了to空间，交换from<->to空间
​				经历了多轮依然存在的对象被copy了多次
​		短停顿
​			时间上 r和m交替的增量回收
​			空间上 部分回收
​			增量回收
​				回收(r)与主程序(m)交替运行，用副表记录主程序引入的新改变
​				r:o1被扫描
​				m:o1 -> o 扫描后更改了引用
​				写关卡
​					截获未访问对象o的引用写入已扫描对象o1,或将o置为可达，或将o1置为未扫描
​				读/传递关卡
​					截获对未访问对象/待扫描对象o的读/写，将o set为可达未扫描
​			部分回收
​				分代 
​					大多数对象早逝特性
​					将堆区分为多个区域 0,1,2,...n
​					n-1区域填满时，对它回收，将可达对象移动到n区

### 后端													

**代码生成**
	IR(三地值码、AST、DAG...) -> 目标机器代码

基本块#CFG的节点
	通过跳转指令进入一个基本块的开始(首指令)，通过一条基本块跳转指令离开基本块(最后一条指令)
	代码优化不考虑中断导致基本块的控制流变化
	首指令
		跳转指令将指令序列划分为基本块，因此跳转指令的目标指令和紧挨跳转指令的指令为首指令
	CFG
		B -> C
			B jump C
			B next is C and B cond jump
		jump 到地址，变为jump到基本块，因为优化时可能对基本块指令进行变更
		**循环识别** 循环中每个节点都存在到达循环入口节点的路径
	后续使用信息
		i: x = c0
		...
		j: y = x + c1 
		j使用了i处的赋值，变**量x在语句i处活跃，变量x的后续使用位置为j**
	局部优化
		基本块自身优化，单个基本块内部(全局优化分析信息在多个基本块流动)
		为基本块构造DAG
			每个变量有个初始节点
			每个语句s一个节点，节点上附加变量表示语句s是对变量最晚定值(最近一次赋值)的语句，子节点是它的运算分量
			输出节点 出口处活跃，代表其它基本块会用到
			数组 当不能确定a[i],a[j]是否指向同一元素，因此保守策略认为存在i==j,因此[]=(写)杀死=[](读)节点 
			指针 
				当不能确定p指向哪个,保守策略认为它们可能指向所有元素，因此*=会杀死所有节点,=*关联所有节点(影响死代码消除)
				数组仅杀死关联同一数组的节点，因此指针别名分析很必要
			函数 保守策略假设函数可能改变了它能所有的所有变量
		公共子表达式 
			加入新节点时寻找是否存在运算形同子节点相同的节点
		消除死代码
			找没有附加活跃变量的根节点, 即根节点表示的计算结果没有被本模块其它计算使用=> 无用的计算 =>消除

​		代数恒等变换
​			常量计算(2 * 3 => 6)，低代价转换(x2 => x<<1)，无用计算消除(x+0)
​			转换是一组规则在构造DAG过程中，可以检查是否满足规则执行变换

```
上述局部变换在花书上介绍的是使用值编号算法来实现基本块内的变换，代数恒等变换的规则被编码到了对值编号的过程中, 而公共子表达式也是蕴含在了值编号中，在值编号过程中进行简单的常量运算
```

​	代码生成
​		跟踪记录值存储在寄存器的信息，不产生不必要的LD/ST，ST取决于是否活跃,LD取决于是否存在
​		reg desc 哪些变量存在此寄存器
​		addr desc 变量存储在哪些位置(reg/mem)
​	全局reg分配
​		策略 将内循环中使用的几个最频繁的var固定到几个reg上
​		图着色reg分配*
​	树翻译方案
​	    	#匹配树，节点替换(归约)，执行动作(语法制导)
​			**将输入的树前序遍历生成串**，树翻译方案转换为语法指导翻译，则可以构造LR分析器
​			可以通过增加特殊的产生式来利用机器特有指令*  #产生式即规则，语法/文法皆为rule
​			相对简单文法+附加属性、断言和动作比一个复杂的纯文法描述更好
​	表达式代码生成

​		-	

​		expr -> expr tree ->附加Ershov数，表示不存储到mem下的reg使用->根据Ershov数生成代码
​		寄存器数量受限时生成ST需要溢出寄存器到内存
​	DP

​		-

​		expr -> expr1 op expr2
​		expr的最优代码，由	expr1和expr2最优代码的某种顺序组合而成 #子问题
​		1.为表达式树T的每个节点n自底向上计算一个Cost数组，Cost[i]表示假设有i个可用reg下，对以n为root的子树求值并存放结果在一个reg的低价
​		2.遍历T,根据Cost数组决定哪颗子树应该被保存在内存中
​		3.生成代码，首先需要被保存在内存中这些子树生成代码



**机器无关优化**
	优化
		一种低层的语义转换，基于一些常见的规则和性质，而不是完全理解了程序并生成一个更优的
		公共子表达式
			表达式expr被计算过且oprands没有改变，则可以避免重复计算
		复制(写)传播
			消除公共子表达式时会引入一些赋值语句(=)
			x = t3,若将后续的对x的读尽可能的用t3代替，则x=t3成为了死代码，直接可以消除x=t3的复制操作*
		死代码消除 计算result不被使用，或代码不可达
		常量折叠	编译时推导expr为常量，则后续使用常量代替expr
		代码移动 	将循环不变式移动到循环外，减少内循环的指令
		归纳变量 强度消减	

```
LLVM优化代码 
标量优化（scalar目录）：  死代码消除（BDCE.cpp[code]，ADCE.cpp[code]，DCE.cpp[code]）,   全局值编号（GVN.cpp[code]）,  代码提升（ConstantHoisting.cpp[code]）， 公共子表达式消除（EarlyCSE.cpp[code]）， 代码下沉(Sink.cpp[code]), 以及各种循环优化等过程间优化（IPO目录）：无效参数消除(DeadArgumentElimination.cpp[code]) , 全局死代码消除(GlobalDCE.cpp[code]), 常量传播（IPConstantPropagation.cpp[code]）， 循环外提（LoopExtractor.cpp[code]），稀疏条件常量传播（SCCP.cpp[code]）,函数合并（MergeFunctions.cpp[code])等
```

​	**数据流分析** 
​			基本块B={s1...sn}，IN[B]=IN[s1],OUT[B]=OUT[sn]

​			传递函数 

​				随着基本块语句的顺序执行，程序的状态变换函数

​				f(B) = fs1 。fs2。fs3...

​			控制流约束 
​				基本块的IN/OUT(入口处/出口处)的状态集是所有可能路径的所有前驱/后继的状态集合的交汇
​				前驱/后继取决于数据流正向分析还是逆向分析

​			优化的保守主义
​				指针/引用/函数参数引入了变量别名，此种情况不能确定变量x的定值，因此只能保守认为x被更改 #优化被抑制
​			 	编译时无法判断路径不可到达，则假设每条路径都会执行

​		到达定值 

​			定值d的程序点p存在路径到达q,且p没有被杀死（新的赋值）则说，定值p到达q,一个路径上的最后定值杀死了先前定值

​			即在程序点p的到达定值集合是d的定制点有路径可到达p的，且所有路径没有对d重新def

​	 	  常量/复写传播需要先进行到达定值分析

​		活跃变量分析
​			x在点p的def是否在从点p出发的(任意)路径上使用，是则在x在点p活跃
​			defB 在B中先定值  
​			useB 在B中先使用，在B的入口处活跃
​			寄存器分配需要进行活跃变量分析，变量在活跃区间内(从def到use)占据寄存器，避免ld/st操作
​			冗余代码消除，需要进行活跃变量分析
​		可用表达式
​			从入口到p所有路径都计算了x+y,且求值后到p点x和y没有改变，则x+y在p点可用(算一次就可以)
​			if base block B对x,y赋值且后续没有计算下x+y，则B kill x+y
​			if base block B一定对x+y求值，则B gen x+y
​			求解各个基本块的可用表达式信息，可识别出全局公共子表达式

​		数据流分析框架(D,V,^,F)
​			D 方向
​			值集V和交互运算^
​			V->V的传递函数族F
​				F是单调的
​				可分配 f(x ^ y) =f(x) ^ f(y)

​	LLVM中的数据流分析

ref: https://www.zhihu.com/question/41959902/answer/93087273

```
dense分析：要用个容器携带所有变量的信息去遍历所有指令，即便某条指令不关心的变量信息也要携带过去
sparse分析：变量的信息直接在def与use之间传播，中间不需要遍历其它不相关的指令（值信息在def-use SSA 图上传播，当def-use边传播跨越基本块时需要使用CFG图，直接跨越了与指定值无关的指令）
llvm使用了sparse分析
```

懒惰代码移动

​	预期执行表达式

​		从程序点p出发的所有路径上都会计算 b+ c的值，且b和c的值就是在点p的的值(oprands没有重新定值)

​	 （1）表达式的多个拷贝会分别放置到**首次被预期执行的程序点**

​	可用表达式

​		表达式是否在所有路径中都在程序点p之前被预期执行

​	 （2）第(1)步后所有到达程序点p的路径都预期执行表达式，则表达式在p可用

​	最早放置策略

​		被预期执行但不可用的，即如果e在B中可用则没有必要放置e在B，在B中计算e，因为在更前面的块的计算可以到达B

​		earliest[B] = anticipated[B].in - avaiable[B].in 

​	可后延表达式

​		一个表达式应该放在后延边界上，即从可后延转变为不可后延的地方

​		 表达式x+y可后延到程序点p的条件是:

​				从入口点到p的所有路径都会碰到一个位置较前的x+y 

​				最后一个这样的位置到p之间没有对x+y的使用

​		前向数据流问题

​		postponable[B].out =  （postponable[B].in + earliest[B]）  - use[B]

​		可后延到基本块入口的表达式集合 传递到基本块B入口的可后延集合 + 可以放置在入口的表达式earliest[B]

​		表达式在B中被使用则不可以后延到B的出口，穿过B时被使用的表达式不能后延，即**入口处可放置的表达式若没有在B中引用的表达式可进一步后延到出口**	

​		#earliest[B]时表达式的可放置位置，如何将此位置向后推一点，就从最早放置位置向后看它是否没有被使用

​		后延meet运算取交集

被使用表达式

​	一个临时赋值语句在其后的某条路径被使用

​	不在其后的某条路径被使用的语句可消除

回边 

​	回边a->b，b支配a的边，所有的回边都是后退边

​	如果一个流图的所有的后退边都是回边，则流图是可归约的

​	**自然循环识别** 

​		给定回边n->d, d加上不经过d的就能到达n的节点集合，d是循环的入口

```
1. loop={n,d},首先将d置为visited避免搜索越过d
2. 在反向控制流图上进行dfs搜索 从n节点开始将访问到的节点加入loop
```

​	 **区域分析**

​	-...-



**过程间分析**

​	流敏感分析 遵循执行顺序的分析

​	流不敏感分析 无视语句的执行顺序

​	简单非精确上下文无关分析

​		将所有函数调用视作goto, 添加两个边call -> , return <-

​		添加一些复制语句，来表示参数传递和返回值

​		经过以上步骤在cfg上消去了过程调用

​	基于clone的上下文相关分析

​		每个上下文clone一次，对clone后的调用图进行上下文无关分析

-。。。-



**指令并行性**
#mlu是cpu+向量机+asic
#gpu 是simd阵列机
	pipeline 
		IF ID EX MEM WB
		不是所有的操作都可以完全流水线化的,如浮点div占据多个时钟周期有时只能选择暂停流水线 #mlu没有stream div是active
		存在依赖使pipeline不能连续进行时，硬件可以暂停pipeline或软件插入nop
	约束
		资源
		控制依赖
			指令i2的result决定了i1是否执行
			投机 * #分支预测
				将nop的cpu空转，改成投机行为，投机失败则不使用result,要求投机行为无副作用
				有空闲资源时可先执行i1(一种预测)
				数据预取，投机性内存访问，提取访存可能访问不可用内存，此时cpu忽略执行
				毒药位 reg <- mem的投机，if mem is invaild , set reg 毒药位,while use it throw exception
				带pred的指令 减少branch,满足cond exec
				M = <R,T>
					R资源集合 
					T 运算集合
		数据依赖
			 真依赖 w r ,后面读要use前面写的值
			 #不同内存位置存不同值可消除后两种依赖
			 反依赖 r w
			 输出依赖 w w
			依赖关系分析，不需要知道具体存储位置，但需要知道是否指向同一个位置
			数组依赖分析 
			指针别名分析
			过程间参数分析
			reg 
				中间代码生成使用无限多个伪寄存器
				无限多个伪寄存器 -> 有限个物理寄存器 ; 映射会产生存储依赖
				硬件reg rename
					并行性要求不依赖(使用不同的寄存器)和使用更少的寄存器分配冲突(尽量减少寄存器使用,1 reg 多用)*
					硬件reg rename 指令集提供少量reg,映射到内部多个reg 1个外部reg被动态调度到多个内部reg，减少依赖性
				#非数值计算和数值计算表现出不同的依赖特性
		基本块调度
			basic block -> 数据依赖图ddg<N,E> N运算，E依赖的运算后续延时
			对ddg带优先级拓扑排序，没有依赖的可流水并行起来
		全局代码调度
			基本块间 数据依赖 + 控制依赖
			投机不能有有害的副作用
			分析路径依赖 =>然后分析基本块内的代码的作用/副作用=>将代码上下移动=>更新数据依赖关系
			支配 src -> dst 入口执行到dst则必然执行经过src; #执行src后不必然执行dst 
			反支配 src -> dst 从src到出口必然经过dst，即执行src后必然执行dst; #执行到dst不一定经过src
		指令/代码移动*
			移动不相关指令代替nop
			当产生数据依赖时为保证正确性，需要插入nop或暂停流水线使先执行的指令执行完成后，依赖的后续指令才能继续执行
			将不依赖的指令调度到互相依赖的两个指令之间以代替气泡(nop)或避免暂停流水线，使资源充分利用

​	**循环的软流水**
​		数值应用经常表现出循环内各次独立的特性,do-all特性，循环软流水，使不同次循环并行起来,循环间有依赖 do-across 也可以从软流水获益

​	软件流水线调度方案

​		1)不同迭代 启动间隔T，	循环吞吐量 = 1/不同循环启动间隔，软件流水的目标是使循环启动间隔最小化

​		2)S(n) 该运算处于迭代开始时刻的执行时间

​		**因此第i个迭代的第n个运算在i * T + S(n)个时钟周期运行**	

​		资源约束
​			R=[r1,r2...],ri可用资源，第i种资源需要ni个，则启动间隔 T = max {... ni/ri...}，若T<1,则将循环展开可获得收益； 选择稳态时连续启动的几个循环，组合它们T个时刻的资源使用，T个时刻的资源都可以被满足，则无资源冲突

​		 寄存器分配 寄存器冲突，奇数次和偶数次使用不同寄存器(**使用不同的资源解除依赖**) 

​		数据依赖
​			n1->n2<@,d>,第i次迭代中的运算n2，必须在第i-@次迭代的运算n1执行d个时钟后才可执行

​			T为启动间隔， S为调度方案 。S(n)代表第i此迭代的运算n在此次迭代的第几个时刻运行
​			n1执行时刻 t1 = (i-@) * T + S(n1)
​			n2执行时刻 t2 = (i)* T + S(n2)
​			n2必须在n1执行d个时钟后执行 => t2-t1>=d => @ x T +S(n2) -S(n1) >=d  =>  T  >= [d - (S(n2) - S(n1))] / @ 
​			令T = d / @ 满足上述约束,存在数据依赖环则启动间隔不小于延时总数/迭代距离之和							     

​	min T #求T是一个整数规划问题
​	s.t.
​		资源约束  T >= max {... ni/ri...} all资源
​		在数据依赖 T >= max {dj /@j } all环
​	启发式求解方法

```
1.从约束得到T的下界T0,T = T0
2.以T为启动间隔执行一个表调度算法
3.若所有节点都能调度则得到T和S，退出
4.否则 T = T+1,转2
```

有环数据依赖图调度

-。。。-

​	**mod变量扩展**#pingpang
​		某变量仅在循环内使用则变量是可私有化的，此变量可转化为一个数组，第i次循环读写第i个元素 #cuda
​		if reg 生命周期为l，启动间隔为T,则一个时间点q=floor(l/T)是活跃的，分配q个寄存器，第i此迭代使用第i%q个寄存器
​		指令条数会可能被扩增q倍，因为要使用不同的reg
​	带断言的指令可以将控制依赖转换数据依赖



**并行与数据局部性**
-



