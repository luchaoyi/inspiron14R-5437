/*
null/nul字节或nul字符的ASCII编码值是0，即在计算中即存储为0b0000_0000
人 '\n'-> 计算机 10
人'\0'->计算机 0
人'0'->计算机48
\转义字符是为了表示不能显示的ASCII字符，null字符是空字符都没有不能显示，用\显示的字符来向人来表达这个字符的存在

标准c库提供了和系统调用一一对应的同名c函数，通过它syscall;通用库函数使用0-多个系统调用构建更度杂的功能，库函数可替换，但系统调用os自带的，是唯一的，不可替换的.
*/	

不带缓冲的文件IO
	不带缓冲指每个read,write都引发内核一个系统调用
	
	描述符:描述符文件指针->文件表项->节点表项->磁盘数据	
		多个不同文件描述符可能指向相同的文件表项
			dup复制文件描述符
			fork父子进程每个相同描述符指向同一个文件表项
						
		多个不同的文件表项可能指向相同节点表项
			不同进程打开相同文件			
			
	lseek仅将偏移量记录在内核中，并不进行IO操作，lseek定位+read/write两个函数操作不是原子性的,pread/pwrite允许原子性定位执行IO
	
	文件系统延迟写
		用户数据写->内核(缓冲区->排入写队列->写入磁盘)
		不带缓冲区指的是相对于标准IO用户数据到内核之间没有缓冲区
		unix内核中设有缓存，当写入磁盘，内核先将数据复制到缓冲区，然后排队，晚些在写磁盘，通常内核需要重用缓冲区时(空间有限),会将所有延迟写内容写到磁盘。
				
文件和目录	
	设备特殊文件
		系统中的设备要么是字符字符特殊文件(不带缓冲，长度可变的访问)，要么是块特殊文件(带缓冲区固定长度的访问)
		若为数据结构提供了访问信息的函数或宏则无需关心数据结构细节
	
标准IO
	标准IO库打开文件时，一个流和一个文件关联,刚创建流没有定向的(定向决定流是字节定向[单字节]还是宽定向[多字节])，使用fwide/freopen来设置和清除流的定向	
	标准库fopen返回File*->File对象，它包括了管理流的所有信息;stdin,stdout,stderr是预定义文件指针
	
	为了减少使用read/write调用的次数,标准IO提供了缓冲并自动对缓冲进行管理
	本数的操作系统遵循,标准错误不带缓冲，打开至终端设备的流是行缓冲，其它流是全缓冲,可以在打开流后使用setvbuf更改缓冲类型
	
	三种IO
		每次一个字符 getc(ungetc可回退一个getc的字符到流)/putc 
		每次一行 fgets/fputs
		直接IO(又称为2进制IO) fread/fwrite
	
	标准IO调用了第三章的IO例程，每一个流都关联了流描述符。fileno可获取流的描述符，fdopen将一个已打开的文件描述符和一个流关联
	内存流没有底层文件，存储在内存，使用FILE指针访问
	标准IO库效率不高,两次复制.用户数据->标准IO缓冲区->内核,标准IO库有很多不同场景下优化的替代产品

进程环境
	exit会先执行一些清理动作在进入内核
		fclose关闭打开流，流被fflush
		atexit函数可登记终止处理函数由exit调用
	存储分配
		内存存储分配函数基于sbrk系统调用，很多malloc/free库函数的实现都使用了malloc内存池技术
		alloca函数在栈中分配空间，栈中分配空间可以随着帧的销毁自动隐式释放	
		有一些高性能的库可代替malloc
	goto不能跨越函数转移，setjmp/longjmp可实现。希望返回的位置调用setjmp,调用longjmp返回到setjmp位置

进程控制
	每个进程都有一个唯一ID,系统中有一些专用进程
		ID=0 调度进程内核的一部分
		ID=1 init 
			由内核调用执行初始化
		ID=2 页守护进程，支持分页操作
	fork后子进程是父进程的副本，父子进程并不共享存储空间，但很多系统使用了COW技术(逻辑上是独立的进程空间但在写之前共享相同的物理页面)
	vfork执行后在exec执行前在父进程空间运行(逻辑上在同一个进程空间,不是副本),子进程需要立即调用exec或exit
	进程调用exec后，进程执行的程序被替换为新程序，新程序从main开始执行.exec不创建新进程，因此不改变pid
	
	wait&waitpid
		wait阻塞调用进程，直到有子进程终止(正常/异常)则返回，wait可获取子进程终止状态相关信息,若调用进程无子进程则立即返回错误
		waitpid可控制父进程是否阻塞和选择等待的进程(wait总是等待第一个终止的子进程)	
		
	为避免竞争和轮询，可以使用UNIX信号机制和IPC进行信号send/recv
	
	进程组 
		进程的集合
		组长进程的进程ID等于进程组ID,组长可以创建一个进程组，创建组中进程，进程组中的进程可以转移到其它组
	会话
		进程组的集合
		会话有一个会话首进程组是控制进程，其它组分为前端进程和后台进程，终端产生的信号会发送到前端进程
		
	
信号是软件中断
	内核和用户都要使用某个定义时，一般不使用同一个文件，内核定义该.h文件,用户定义一个.h包含它
	信号处理方法，使用signal函数设置
		忽略，SIGKILL和SIGSTOP不能忽略
		捕捉，SIGKILL和SIGSTOP不能捕捉
		执行系统默认动作 
		
		/x
		
		设置了SIG_IGN的忽略和某些信号SIG_DFL中执行默认动作的忽略是不一样的
		设置了信号SIG_IGN是明确告知内核忽略信号，SIG_DFL是为信号执行了系统的默认动作，而此信号的默认动作是不做动作
		
		僵死进程,处于僵死状态的进程,进程退出但保留资源未释放的进程的状态是僵死状态
			每个进程退出时内核释放其占用资源，保留一定的信息，并产生SIGCHLD信号
			当父进程调用wait/waitpid来取保留信息时，保留信息才会释放,如果父进程不调用wait/waitpid则保留信息不释放，进程号也一直被占用，进程退出但保留资源未释放的进程的状态是僵死状态.长期僵死会造成内存泄漏，占用进程号资源
			避免僵死进程
				父进程直接调用wait/waitpid为僵死子进程收尸，
				父进程捕捉信号SIGCHLD，在回调函数中wait/waitpid(SIGCHLD系统的默认动作是SIG_DFL忽略)
				设置SIG_IGN(linux系统如果设置了SIG_IGN则子进程退出后转交给init处理),常用于高并发服务器	
				fork两次，子进程fork孙进程后退出，及时清理，孙进程成为孤儿进程执行任务，退出时由init处理
				
		孤儿进程,父进程在子进程前退出的进程，若父进程在子进程前退出，则子进程由init处理(收养)	
		x/
		
		kill将信号发送到进程或进程组,raise将信号发送给自己
	信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集，屏蔽字阻塞信号可保护不希望中断的代码
		sigpromask可以通过修改屏蔽字，来BLOCK/UNBLOCK信号
		sigpending返回在阻塞期间接受到的阻塞信号的集合
		sigaction检查/修改与指定信号关联的动作，很多系统使用它来实现signal函数,此函数在进入处理函数之前，会根据参数屏蔽指定的信号，在完成后恢复以前的设置。		sigsetjmp&siglongjmp 提供了在信号处理函数中的长转移，这两个函数会get&set信号屏蔽字;调用sigsetjmp后设置一个flag=True,在siglongjmp调用前检测它来提供一种保护机制.
		sigsuspend 设置信号屏蔽字并挂起，捕捉信号后执行信号处理函数，信号处理函数返回后，sigsuspend返回，返回后恢复信号屏蔽字到调用sigsuspend之前;sigprocmask+pause可以实现解除阻塞并挂机等待信号，但两个函数操作不能保证的原子性,sigsuspend可以解决此问题。
		
		
			
线程，pthread是POSIX线程接口
	线程ID,一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量，线程私有数据
	线程终止
		任意线程调用进程终止函数则整个进程都会终止
		pthread_exit
		返回
		可以被同一进程其它线程取消
	
	pthread每个对象(thread,同步对象等)都关联一个属性对象,属性配置是对pthread对象的配置，通过生成设置属性对象并与pthread对象关联来控制对象的行为;属性对象提供了init/destory/get*/set*等函数,生成并配置号属性对象后，在创建pthread对象时，将其传入用以配置pthread对象
		线程属性对象
		同步对象属性
			进程共享属性，若支持并设置了进程共享属性，则同步对象从进程共享内存中分配，这样pthread同步对象可以用于进程同步
				
	重入
		多个线程相同时间可能调用相同函数，函数可被多个线程安全调用则是线程安全的	
		
	多线程&信号
		每个线程都有自己的信号屏蔽字，但是信号处理是线程共享的
		
	pread/pwrite让lseek+read/write为一个原子操作，在多线程环境下非常有用
	
守护进程
	常常在os引导时启动，在系统关闭时终止，没有控制终端，运行在后台
	ps -axj/-efj可显示，LINUX中内核守护进程在[]中	
	用户层守护进程的父进程是init进程
	单实例守护进程，一个时刻只有一个副本，文件和记录锁提供了方便的互斥机制，可用来实现单实例守护进程
	
高级IO
	IO两阶段
		等待数据到达内核缓冲区，描述符就绪状态
		将内核缓冲区数据复制到用户buf
	非阻塞IO 不阻塞阶段1
	字节范围锁(记录锁) 锁定文件一个区域(也可能是整个文件)
	IO多路转接
		构建感兴趣的描述符列表，然后调用多路转接函数直到有描述符准备好才返回，返回时会得到哪些描述符准备好了
		select感兴趣描述符列表为NULL，则提供了一个比sleep更精确的定时器/x nanosleep 系统调用睡眠指定时间后被唤醒，sleep库函数调用nanosleep实现 x/
		pslelct与select类似，but可以指定sigmas           
		
		

	
	异步IO
		描述符的状态系统不会主动通知，需要我们去查询，信号机制提供了一种以异步形式通知事件已经发生的方法;异步IO使用一个信号通知进程，关心的描述符的关心事件已发生。(被通知，是需要other帮助才可实现)
		POSIX使用AIO控制块struct aiocb描述IO操作
			显式指定offset确定r/w的起始位置，不影响系统维护的文件offset，若异步IO以追加模式打开文件则aio_offset被忽略;sigevent参数指定异步IO请求完成后通知信号or调用函数。
			aio_write/aio_read.函数返回时，异步IO请求被排入等待队列，返回结果与实际的IO操作结果无关			
		内存映射IO
			mmap将磁盘文件映射到内存，munmap解除映射.映射到存取区后会返回存储区的起始地址，可以使用内存操作函数(like memcpy)进行读写
	readv/writev 一次读写多个非连续缓冲区
	
进程间通信
	管道
		pipe返回两个描述符，在一端写，在另一端读，pipe是未命名管道，只能在相关的进程使用
	FIFO	
		称为命名管道,FIFO是一种文件类型，创建时指定路径名，路径名存在于文件系统中
		mkfifo创建fifo，然后使用open打开,使用文件IO操作
	XSI IPC(消息队列，信号量，共享存储)
		用一个非负整数的标识符引用，标识符是内部名，外部使用一个key和标识符关联，key为外部名;key-|-id
		缺点
			在系统全局范围内起作用，除非显式删除，否则进程终止数据和IPC对象都存在
			不能使用文件操作，不能使用select	
			
		消息队列
			链表
			没有引用计数，因此删除消息队列会直接删除，影响其它正在使用的进程
			速度优势已经不大，不推荐使用
		信号量
			是一个计数器，控制共享资源访问;PV操作,P申请资源 count--;V归还资源 count++;count==0时P操作将阻塞进程,V count++ count>0,唤醒被阻塞进程
			信号量的基本操作是原子操作，一般在内核实现
			有的进程终止时如果没有释放信号量，则会造成全局影响。sem_flag设置SEM_UNDO标识，则进程正常or异常退出时归还信号量.undo撤销可理解做过的所有PV操撤销，还原到操作前的状态.				
	
	POSIX信号量 /x so I 认为 posix 信号量 更靠谱 x/
		意在解决XSI信号量缺陷 
			性能明显好于XSI信号量
			使用更简单
			有引用计数
			POSIX信号量只能+1,-1;
		P:
			sem_wait 阻塞
			sem_trywait 直接返回错误
			sem_timewait 阻塞指定时间
		V:
			sem_post
		信号量实际上是一种同步原语而不是IPC	
	
	
/x
多进程/多线程同步原语
	信号量 PV操作
	Barrier
	锁
		mutex lock
		递归 lock 
		rw lock 
		spin lock
	条件变量
	CAS 
多进程IPC
	pipe,FIFO,mmap,消息队列,socket,...?
	
x/

socket
	套接字接口可以采用许多不同的协议，因特网标准协议是TCP/IP协议
	socket描述符在UNIX中被当作一种文件描述符
		数据报套接字 UDP 寄信f
		流套接字     TCP 打电话
	套接字可以读写，双向通信，shutdown可以关闭套接字读/写端
	TCP/IP协议指定使用大端字节序，存在字节序转换函数或宏 主机<->网络
	
	socket创建套接字
	bind 使用bind将关联套接字和地址,sockfd-sockaddr
	listen表示愿意接受请求，使用了listen的socket表示可以接受连接请求
	accept获得连接请求并建立连接，在开启了listen状态的socket上调用accept
		sockfd是阻塞模式则阻塞等待connect请求到来,非阻塞模式则直接返回-1
		accept返回一个新的套接字描述符，该描述符和客户端建立连接，并将获取的客户端地址信息填充到更定的缓冲区
	connect 面向连接的服务在交换数据之前需要建立一个连接(like TCP),connect的sockdf如果没有bind sockaddr则connect会bind一个默认的sockaddr
			无连接的服务调用connect不会建立连接，但设置了通信方的地址
	一端connect,一端accept返回两个sockfd sockfd<->sockfd建立一个连接
	
	send is write->返回时表示数据已经无错误的发送到网络驱动程序了，不代表接受到
		无连接的数据发送使用sendto在发送时指定地址，或使用connect指定地址然后才可使用send
		sendmsg可以指定多个缓存区传输数据，类似writev
	
	recv is read <- 
		recvfrom接受数据可获取发送者的地址
		resvmsg 将接受到的数据送入多个缓冲区,类似readv,接受数据时如果服务器不在运行状态则会无限期阻塞，为避免无限期阻塞可以考虑设置alarm
		面向无连接的套接字数据包到达时可能已经没有了次序，数据包可能会丢失
		recv没数据可用会阻塞，send输出队列没有足够空间发送消息时send会阻塞;非阻塞模式下，会直接返回错误
	
	带外数据
		某些协议支持的可选功能,取决于协议支持;带外数据先行传输，即使传输队列已经有数据
		TCP支持带外数据,UDP不支持;TCP支持一字节的带外数据,旧的紧急数据字节接受前新的到达则旧的丢弃
	
	unix domain socket(简写uds)
		高级IPC,同台计算机进程通信,速度快于inet socket;流和数据报两种接口;服务可靠，不丢包不出错;
		socketpair可以创建无命名的互联uds,类似一个全双工管道
		命名uds使用socket创建
			sockaddr_un包含一个路径名，当bind sockaddr_un到socket时，系统会使用该路径名创建一个S_IFSOCK类型的文件
		
		描述符传递
			父进程向子进程可以打开描述符后通过fork传递描述符
			unix系统提供了无关进程传递描述符的方法
				两个进程之间首先要创建一个unix域套接字，然后使用sendmsg发送一个特殊消息,这个消息由内核专门处理，会把打开的描述符发送到接受进程
				
		uds还可以传递另一种特殊数据 用户凭证
		
终端IO
	工作模式
		规范模式输入处理，以行为单位处理，每个读请求最多返回一行(default)
		非规范模式，输入字符不装配成行
	波特率 is 位/秒(b/s)
	
		
		
	
	
	
	
	
	
	
			
	
		
                                        
