unix函数发送错误时，一般设置错误码到errno，然后函数返回-1,使用包装器可以将出错处理归类抽象到一个函数，AOP是OOP的补充手段

IPC的持续性
	进程级别 直到进程关闭
	内核级别 直到内核自举or显式删除
	文件系统级别 显式删除
		
fork exec exit在父子进程间对不同的IPC有不同的效果

迭代服务器 服务器逐个处理客户请求
并发服务器 为每个客户fork一个子进程(或创建线程,以及进程池，线程池技术)处理客户请求



消息传递
	匿名管道 一般只用于有亲缘关系进程，无亲缘进程需要使用进程间传递文件描述符的技术
		pipe  单向
		popen 创建pipe启动一个新进程执行shell command,此进程可以得到command进程的标准输入(mode r)或写到command进程的标准输出(mode w)
		
		socketpair可以创建无命名的互联uds,类似一个全双工管道	
	FIFO(命名管道)
		mkfifo 创建FIFO,已存在则返回错误
		unlink 如果不在使用fifo，删除文件系统中的pathname,内核为fifo和管道维护一个访问计数器unlink不影响已经打开fifo的进程
		open/fopen 打开FIFO 单向数据流，打开时只能指定r/w,不能r&w        (flag参加APUE第3章，mode参见APUE第4章)
			阻塞模式下open打开来写会阻塞直到有进程调用open打开来读,同理open打开来读会阻塞直到open打开来写.
		close 
			管道和fifo最后一个打开来写的进程调用close时会为打开来读的进程产生一个EOF
			当管道和fifo的最终close发生时(所有读写进程都close),残余数据会被丢弃
			
		fcntl可更详细地设置获取和设置fd的属性
		write原子性 一次写入<=PIPE_BUF字节可以保证本次写入的原子性
		
		pipe和fifo的数据是字节流(类似TCP连接)，不存在记录边界,在字节流IO中分割记录的方法由使用进程实现
			添加进程规定的标识消息边界的特殊字符，如\n
			显式长度,每个记录前冠以长度
			每个记录一个连接，通过关闭连接指示记录结束								
								
	posix消息队列
		写权限线程放入消息，读权限线程取出消息,每个消息是一个记录，提供记录边界,并不需要通信双方等待(类似udp数据报),内核级别持续性
		优先级队列,消息有优先级,优先接受最大优先级消息
		大多数IPC机制并不能标识消息发送者，而由发送者主动发送的身份标识是不可信的可能伪造
		
		/*ulimit -a可查看进程最大资源数的系统配置
		ipcs可以查看系统范围内ipc相关信息
		*/
		
		阻塞等待消息队列中放置消息或非阻塞+轮询来等待消息到达都是同步方式，posix消息队列允许异步事件通知(产生一个信号/创建线程执行指定函数callback,使用mq_notify注册,通知只在队列为空时放置消息时产生);只允许一个进程注册接受某队列的通知，当有进程阻塞在此队列时不产生通知，被阻塞进程优先解除阻塞获取消息		
		
		send 队列为空则唤醒recv阻塞进程或发送信号到注册进程
			队列为满则阻塞等待或非阻塞直接返回错误
		recv
			队列为空则阻塞或非阻塞直接返回错误
			取走消息前队列满则解除阻塞的send进程
		posix实时信号，实时代表了消息是排队的，按FIFO多次递交,信号产生时携带更多信息。非实时信号不排队只递交一次,信号可能会丢失	
		
	system V 消息队列
		可以返回指定type字段的消息，posix不可以;不支持异步通知,posix可以
		若以进程号标识type字段则多个进程可复用一个消息队列
		
	/x
	共享内存+mutex+条件变量->可实现->消息队列
	cond+mutex->可实现->读写锁
	FIFO->可实现->信号量
	cond+mutex+共享内存->信号量
	x/
	
同步
	mutex
	cond
	读写锁 共享读-独占写
			获取读锁时，如果有写者则阻塞，获取写锁时，有写这或读者则阻塞
			设计读写锁时应考虑要优先考虑等待的写者or优先考虑等待的读者
			当read比write更频繁时，读写锁性能更高
			
	fcntl记录上锁
		记录(字节范围)上锁是针对某个字节范围，文件上锁是特殊的记录上锁针对整个文件的字节范围 
		
		强制性上锁,内核会检查验证其它进程的read和write，如果和强制性锁冲突则操作不允许，阻塞或非阻塞返回错误
		建议性上锁,不会验证read和write操作，建议性上锁不能阻止其它进程的r/w操作,即进程r/w时如果遵守规则使用建议性锁，它才起作用，如果进程不测试文件是否加锁而直接r/w，则建议性锁并不能锁定阻止对锁定的byte范围的r/w操作
		
		fcntl(fd,cmd,arg),arg描述了锁的类型，字节范围，以及加锁的pid,设置arg可以锁定整个文件
		关闭文件描述符或加锁的进程退出，则记录锁被清理，记录上锁应该避免使用带缓冲的IO,锁和pid关联因此不能被fork继承		
		记录上锁也是读写锁，因此需要了解使用的锁优先考虑等待的写者or优先考虑等待的读者的问题
	
	posix信号量 
		sem_open有名信号量，和一个name关联,总是可以在进程间共享
		sem_init基于内存的信号量，设置了shared参数才可以在进程间共享,进程共享的内存信号量在共享内存中		
	system v信号量


共享内存区
	最快的IPC，映射后数据操作将不在涉及内核
	mmap 
		内存映射文件
			将普通文件映射到内存以提供内存映射IO，使用内存映射文件，所有对文件的IO都在内核掩盖下完成，用户只需要存取内存
			open ->fd,mmap fd->addr,munmap解除映射关系
			设定了MAP_SHARED标志可以在进程间提供共享内存区,进程对共享内存区的修改会写回到被映射的文件(以提供随文件系统级别持续性)
			内存->文件的同步是由内核自动负责的，可调用msync主动同步
			
		提供匿名内存映射
			BSD mmap(fd=-1,flags=MAP_SHARED|MAP_ANON) 不映射文件，创建一个共享内存区，初始全0
			SVR4 内存映射特殊设备/dev/zero来创建一个共享内存区
			
		posix共享内存区对象
			shm_open name->fd,取得fd,此fd是posix共享内存区对象的描述符,对象由fd描述，因此可以使用fdstat获取对象信息
			mmap fd->addr;共享内存区对象可视为一个特殊的文件
			
		system v共享内存区
			shmget->shmid,创建or打开共享内存区，返回一个标识符
			shmat shmid->addr 将共享内存区attach到进程空间,逆操作shmdt
			
RPC 
	门 同一台主机的RPC
		服务器
			door_create 创建门的函数,将提供服务的远程过程和门关联,返回一个门描述符fd
			fattach fd->pathname,为fd在文件系统中关联一个pathname
			
		客户端
			open(pathname)->fd,根据pathname获取门fd
			door_call fd,RPC,门的调用是同步的/*服务器服务过程，通过door_return返回*/
		
		服务器为每个RPC创建一个服务线程执行RPC,因此服务过程must保证线程安全
		服务器过早终止则door_call会返回错误，客户端过早终止服务器会收到线程取消的请求
		身份验证 门服务器可验证可验证客户端凭证，客户端可获取服务器信息
		门和unix域套接字可传递描述符fd,传递的fd在不同进程中fd数字不同但关联了同一个文件表项
		
	Sun RPC 不同主机通过网络连接		
	
		编写rpc说明文件.x,描述服务过程
			服务过程使用程序号，版本号，过程名标识
			输入参数，输出参数结构体
		rpcgen 根据.x自动生成client stub和server stub,stub函数掩盖了网络通信
		客户端调用clnt_create指定服务器ip,程序号，版本号，通信协议获取一个CLIENT 句柄,调用生成的client stub传入句柄和输入参数执行rpc
		服务器编写服务过程，服务过程被server stub调用
		
		本地端口映射器rpcbind
			服务器需要运行rpcbind，rpc服务器捆绑一个临时端口，然后向rpcbind注册自己的临时端口
			rpcinfo -p 可查看以及注册的rpc程序,包含程序号，版本号，协议类型，端口号等信息
			客户端启动后clnt_create向rpcbind发送rpc请求得到服务器的服务端口			
			
		超时和重传策略
			运行时系统为客户端的每次rpc调用产生一个XID标识随调用消息一起发送，服务器返回消息时XID不变，客户端验证XID来确认是否正确的应答
			服务器启用告诉缓存则重复发送的rpc(查看XID)不在调用服务过程，调用结果已经缓存直接返回
						
		等势过程 可以多次安全调用的，使用udp不成问题
		非等势过程 每次调用会产生状态的改变,建议使用tcp，意义重大的非等势过程建议使用事物管理系统(如机票预定，银行账户)
		
		XDR(外部数据表示) 不同机器的数据格式可能不同,xdr标准是描述数据的语言，编码数据的规则
		/x
		更上层跨机器的数据标准格式有json,xml等
		x/
		
