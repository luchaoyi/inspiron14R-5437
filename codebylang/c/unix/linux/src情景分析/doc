8086 段寄存器:offset
80386
	段式内存管理
		GDTR LDTR 指向段描述符表基地址,Intel意图内核使用GDT,各个进程使用LDT
		段寄存器索引段描述符表取得表项，表项包含了段信息(基地址,...)
		基地址+offset->线性地址/物理地址
	优先级 0-3
	页式内存管理
		段式映射得到的地址不是实际物理地址，而是线性地址
		线性地址 [页目录10|页表10|页内offset 12]，CR3指向页目录基地址
		页表项包含了页基地址，以及页标志位

---------------Linux--------------
内存管理
	虚拟映射模型 
		三级PGD PMD PT[PTE...]，因此一个地址分为四段三个索引，一个offset,PTE包含了页的基地址以及其它信息
		三级是虚拟的，落实到具体cpu和mmu上会有所改变
		MMU负责翻译 线性地址->物理地址，MMU设有TLB可缓存PTE加快翻译速度			
		i386
			Intel意图内核使用GDT,各个进程使用LDT
			Intel提供CS,DS,SS寄存器意图进程映像分为代码段，数据段，堆栈段
			段+页管理
		Linux 	
			设计时堆栈段和数据段寄存器设置相同值不区分,只提供 内核CS|DS,用户CS|DS四种不同段寄存器值
				TI=0  只使用GDT
				RPL=0,3 只使用两个权限  			
				GDT四个段描述符基地址全为0,Linux段式管理只是为适应Intel cpu,因此段式地址映射后不变,Linux不使用段式管理
				
			页管理 
				物理内存反应页面供给	虚拟内存反应页面需求 PGD PMD PT[PTE...]是桥梁
				
				物理内存:页面的供应
					内核检测物理内存大小，为每一个物理页面建立page结构描述，组成一个全局数组mem_map，同时将物理页面划分为几个管理区zone_struct描述	
					进程看到的是虚拟内存,内核看到的是物理内存，内核可访问所有物理页面,用户的内存申请提的是需求，虚拟内存空间，由内核负责管理物理内存
						分配物理页面建立映射关系为进程供给页面
						页面换出 
							内核线程kswapd
						页面换入
							缺页中断	,物理页面不在内存
							
				虚拟内存:页面的需求
					每个进程有自己的虚拟空间,进程需要使用的虚存不连续，形成若干个区间使用vm_area_struct描述
						同一个区间的页面有相同的访问属性
						给定虚拟地址寻找属于的区间是频繁的操作，区间较多使使用AVL加速搜索
					mm_struct 每个进程一个描述用户空间
						task_struc{->mm_struct{->vm_area_struct}}
						进程映像中的代码段，数据段，堆栈段，存储堆的start/stop /x进程映像的段和段式管理的段不同x/										
						vm_area_struct表明了进程对虚拟内存的需求，但并不保证虚拟页面已经映射
						
					只读的虚拟页面，开始一律映射到同一个物理页面，页面内容全是0，可写的页面才调用alloc_page()分配物理页面
					/x中断压入下一条指令地址，返回时继续执行下一条指令,异常压入	无法完成的指令地址，返回时重新执行一遍上次无法完成的指令x/
					
					系统空间页面不被换出 
						内核中的代码和全局量，没有分配和释放的过程，静态，常驻内存
						内核动态申请的内存，由内核管理释放，常驻内存
											
				内存申请
					物理
						slab 
							缓存内核运行时需要频繁动态申请和释放的一些常用的数据结构，slab由多个物理页面组成，每个页面包含多个object
							kmem_cache_create可以为对象建立专用slab队列基础设施	
							kmem_cache_alloc从slab缓冲队列的分配内存
							slab队列增长的空闲slab由kswapd负责检测释放
						alloc_paces分配单位为页面，小对象造成浪费		
						kmalloc为不具有slab队列且不足一个页面的数据结构分配内存	
					虚拟
						vmalloc从内核的虚存空间分配需存以及对应的物理内存，分配内存不被换出
						brk
							从用户的虚拟空间分配内存,brk向内核批发一批虚拟内存，由malloc零售给进程
						mmap 文件映射到进程虚拟用户空间

中断
	外部中断 完全是异步的被动的不可预测的
	内部主动产生的软中断
	异常 内部产生但被动
	中断发生在用户态时,RPL 0->3 用户堆栈切换到内核堆栈
	IDTR 指向当前中断向量表IDT
	
	中断服务一般在关闭中断请求下执行，避免嵌套的复杂化，中断一般分两部分
		上半部 关闭中断不受干扰完成一些关键性操作
		下半部 允许推迟延后做


进程 
	task_struct
		内核创建进程时分配两个页面(8KB),底部约1KB用作task_struct,剩余约7KB用做进程的的系统空间堆栈，系统空间堆栈大小固定，因此中断服务程序，内核软中断，驱动程序应避免嵌套太深，以及使用太大的局部变量,current宏指向当前运行的task_struct
		{
			state	 
			性质
			资源
			组织 
		}
		
	内核中的互斥操作
		semaphore{
			atomatic_t count; //可用资源数 
			int sleepers; //被阻塞进程数
			wait_queue_head_t wait;
		}	
		
文件系统
	task_struct{
		fs->fs_struct 文件系统信息
		files->files_struct 已打开文件信息 file数组
	}
	
	文件系统安装
		磁盘未mount之前是作为一个线性无结构字节流来访问的，可直接读写设备文件，mount设备上的文件系统成为可访问的
	文件打开 
		file结构代表一个独立的读写上下文
		sys_open
			获取文件打开号 fd
			得到文件打开结构	f
			fd_install(fd,f) 关联
	文件读写
		用户空间<-> |inode->...->文件读写缓冲页面队列| <->设备缓冲区队列			
		
		
系统引导
	i386 cpu启动/reset CS:IP=0xffff:0->0xffff0,此位置有一个ROM存储初始引导程序(BIOS)，初始引导从磁盘读入引导扇区
	引导扇区MBR 512字节 引导装入程序 磁盘分区形成多个逻辑磁盘，引导装入程序可选择逻辑磁盘装入其引导扇区
	逻辑引导扇区 载入内核映像 解压缩 
	系统初始化
		startup_32 主CPU先运行，其它cpu停机，cpu初始化
		start_kernel 
			e820图 物理内存信息
			检测获取系统资源信息并初始化
		第一个内核线程init 
			第二个内核线程 keventd
			安装根文件系统		

SMP
	原子性
		LOCK前缀 指令执行期间对总线加锁
		xchg 指令自动锁总线	
	
	缓存内存一致性
		Intel cpu snooping技术 
			专用硬件监视系统总线，发现CPU写操作，且目标有高速缓存副本则自动废弃此缓存线
			自动保持一致性，对软件透明
	中断 
		APIC代替8259A 
		
	进程调度
		每个cpu有自己的运行队列，空闲时偷取其它cpu的队列
		进程可绑定亲缘性	

