配置内核
	通过配置选择内核支持的功能，根据配置将功能相关的文件编译进内核
	CONFIG_???
编译内核
	make -jn n核并行编译
安装内核
	按照bootloader规定移动内核到指定位置

gnu c扩展
	static inline 内联函数
	asm 内联汇编
	分支声明,声明告诉编译器信息让编译器可以优化
		

进程
	进程创建时申请2个页面，32位2页8KB,1KB被task_struct占用，其余为内核栈,task_struct 包含了内核管理进程的所有信息的大结构体,task_struct存放在一个双向链表中，称为任务队列
		进程状态.state
			运行/可运行
			可中断 被阻塞，但可以接受信号被提前唤醒
			不可中断 被阻塞，在等待状态不对信号响应
			停止 不能运行
			被追踪
		进程上下文
			进程执行系统调用陷入内核空间，此时 内核代表进程执行 处于进程上下文,进程上下文中current宏有效
		进程树
			current->parent 执行符进程的指针
			current->children子进程链表
		进程创建
			fork/vfork and exec
			copy on write
		进程退出
			释放相关资源，保留内核栈，thread_info，task_struc等(即进程创建时的2个页面)待被wait
			
	线程
		Linux在内核没有为线程提供专门的数据结构和调度算法,Linux线程使用task_struct表示，线程被内核视为一个和其它进程共享资源的进程，
		线程仅是Linux进程共享资源的一种手段，线程创建和fork创建进程都调用clone创建进程，clone标志指定了父子进程间需要共享的资源,线程共享更多资源
		内核线程 运行在内核空间，没有用户空间，只在内核空间运行
		
	主动睡眠
		进程因等待某些事件发生而主动将自己投入睡眠
			进程将自己投入某个等待队列，投入等待队列是为了在事件发生时被唤醒,投入等待队的进程注册唤醒callback函数由__wake_up()调用执行唤醒
			设置进程状态为不可执行状态+移出rb tree+调用schedule() 
	被动唤醒
		进程因等待事件发生，被唤醒
			移出等待队列
			设置进程为TASK_RUNNING+加入 rb tree +调用schedule() 
	
			
								
系统调用
	每个系统调用???在内核中都有一个对应的sys_???
	sysenter 0x80 -> sys_call() 通过调用号指定系统调用,通过寄存器或寄存器->内存传递参数，返回值eax
	不建议自己实现系统调用，替代方法
		实现一个设备节点,对此实现read/wirte(信息的IO)
		使用ioctl
		
中断&异常
	中断
		int产生的软中断
		外部硬件产生的中断
	异常
		处理器执行指令检测到错误,如缺页，除零错，保护违例
		
	注册中断处理程序 
		若设备需要使用中断，那么驱动程序需要注册一个中断处理程序,使用request_irq()
		卸载驱动时需要注销中断处理程序，使用free_irq()
	共享中断线
		同一个中断线，被多个设备注册，中断发生时，内核将依次调用在该中断线上注册的程序，中断程序必须知道自己是否为此中断负责(类似以太网总线广播,每个设备都收到消息，处理/丢弃由设备决定)
		
	中断上下文 区别与系统调用时的进程上下文,中断不代表任何进程因此不能被调度->因此中断上下文不能睡眠->因此中断处理程序应该迅速，简洁
	禁止中断可以确保其它中断处理程序不抢占当前代码，但中断禁止不能阻止其它处理器的并发访问,因此内核代码还要获取锁来防止其它处理器的并发访问
	2.6内核后每个处理器有1页大小的中断栈
	
	下半部
		中断处理流程推后执行的那一部分,中断处理程序需要执行的越快越好，因此中断处理流程如果很复杂则尽量将复杂的操作,移到中断处理程序之外推后执行,这称为中断处理流程的下半部，上半部是必须放置在中断处理程序中的操作，如时间敏感，硬件相关，保证不被中断的代码(中断上半部会屏蔽cpu中断)	
		有三种机制实现将工作推后
			软中断 编译期间静态分配且数目为定值
				实现软中断处理程序
				注册软中断处理程序
				中断上半部在返回前会标记触发软中断
				待处理软中断被内核检查执行
					硬件中断返回时
					当大量软中断出现时，内核会唤醒一组内核线程处理这些负载
					显式检查执行的代码，如网络子系统(时间要求比较高)
				do_softirq循环执行标记的软中断，并清除标记
				软中断适合时间要求最严格的下半部
			tasklet 是一种注册的软中断
				tasklet注册为软中断，并模仿软中断机制实现支持下半部执行
			工作队列
				工作队列把工作推后，交给内核线程执行，下半执行在内核线程的进程上下文中运行睡眠和重新调度

		/x
			推后任务需要睡眠则可选择工作队列，若不需要选择tasklet,如果时间要求高则选择软中断，当前只有网络子系统和SCSI直接使用软中断
		x/	
				
内核直接支持的同步
	原子整数 atomic_t
	原子位操作
	自旋锁 代码不会睡眠,适合短时间非阻塞临界区
	信号量 是一种睡眠锁
	mutex 可以睡眠的强制互斥锁,可以使用计数值为1的信号量实现互斥，但互斥体更加高效
	完成变量	
		wait_for_completion 等待在某个完成变量
		complete 唤醒等待在完成变量上的任务
	sqe锁 内核2.6引入 优先于读的读写锁
	
	屏障 
		确保读写指令顺序执行，避免被编译器/处理器对指令重排
		内存屏障 阻止cpu
			rmb() 确保rmb()之前的读操作不会重排到该调用后 
			wmb() 确保wmb()之前的写操作不会重排到该调用后 
			mb()  读写屏障
			smp_??? smp内存屏障
		编译器屏障 阻止编译器
			barrier()
			
时间
	系统时钟中断以固定频率触发，内核知道时钟中断间隔,间隔时间称为tick
	高HZ可以提高更精确的时间降低调度延迟，但耗电
	实时时钟RTC 存放在cmos中的墙上时间,内核以启动时读入RTC到xtime结构中，然后在时钟中断处理程序中更新xtime
	
	内核定时器 
		由用户设置，由时钟中断程序负责处理的对象，为用户提供定时功能
		设置超时时间和指定超时调用的处理函数,超时后由时钟中断处理程序激活指定的超时调用的处理函数
		内核定时器时间单位是节拍数
		
	延迟函数delay
		ms>us>ns
		延迟有两类	
			睡眠指定时间后被唤醒，不能保证精确延迟
			忙等待，空循环指定次数相对睡眠更精确，但cpu被占用
			/x持锁忙等待和禁止中断是最粗鲁的做法x/
			
物理内存管理
	每个物理页都使用一个 struct page结构描述
		页状态
		引用计数
		虚拟地址
	区
		特性相似页的分组
		
	
	alloc_pages 以页为单位分配内存
	kmalloc 以字节为单位的内存分配，物理地址逻辑地址连续，比c malloc多一个flags参数,kfree释放
	vmalloc 
		以字节为单位分配连续的虚拟内存，但不保证物理内存的连续
		分配不连续的物理内存，修改页表映射，不连续的物理内存被映射到连续的逻辑地址
		性能考虑,内核代码多使用kmalloc
		vfree释放
	slab层 
		是一种内存池技术,kmem_cache->{slab_free,slab_full,slab_partial}->slab->page{object,object,object}
		一个slab申请1-多个页面，将申请的页面划分为固定size的object进行管理,每个object就是size大小的内存空间
		内核为频繁申请释放的小对象(如进程描述符对象，索引节点对象)创建一个kmem_cache生成大量的object
		从slab层申请内存时直接返回kmem_cahe中缓存的小对象
								
	高端内存分配
		分配高端内存页后需要主动映射到逻辑地址
			kmap 建立永久映射返回逻辑地址，函数可睡眠只能用于进程上下文,kunmap解除映射
			kmap_atomic 可覆盖的临时映射
			
vfs
	vfs定义接口，实际的文件系统实现接口供vfs调用
	vfs采用面向对象设计(struct+函数指针)，每个主要对象都包含一个操作方法的结构体	
		superblock 代表已安装文件系统
		inode 代表一个文件,普通文件和目录都是文件用inode表示		
		dentry /xmy idea 应称为路径名对象x/
			为方便查找操作，引入了dentry(类比数据库中的索引)
			目录项对象可以指向一个inode
			目录项对象不存在于磁盘中，是vfs根据字符串路径名现场创建存在于内存中
		file 文件对象
			代表进程已经打开的文件，用户进程直接处理的是file对象，而不是superblock/inode/dentry
			包含偏移量，访问模式等信息
			
进程地址空间
	进程用task_strutc描述,进程地址空间使用mm_struct描述
	进程地址空间上一段内存区域使用vm_area_struct描述,vma 使用flags标识这段虚拟内存区域的权限信息(read,write,exec,shared...)
	/x
		进程地址空间是一片连续的空地
		内存区域是在进程地址空间上划分出来的有界限有权限的田地，内存区域就是一组连续的相同属性的页面集合
	x/
	
	每个进程都是自己的页表,线程共享页表，硬件查询页表完成虚拟地址到物理地址的转换，linux使用3级页表
	
	

页高速缓存
	减少IO操作的内存对磁盘缓存，磁盘物理块缓存到内存物理页面加速磁盘访问
	
	回写 写文件操作写到物理页面，然后将页面标记为脏加入脏页链表，由回写进程周期型将页面写到磁盘
	读 内存命中则直接读内存，否则读磁盘
	
	lru 
		访问顺序排序的链表，淘汰链表尾
	lru/n
		维护n个链表,页面访问一次加入第一个链表，页面再次访问则加入第二个链表,一次类推
		第n个链表的页面，最近被访问了n次,第n个链表太大则淘汰页面到n-1级别列表相当于计数减小
		从第1级链表尾淘汰页面		
		
块IO层
	能随机访问固定大小数据片的硬件设备是块设备
	字符流顺序访问，字符设备
	管理字符设备访问比较简单，管理块设备访问比较复杂
	
	linus电梯
		将磁盘请求按扇区排列，若多个请求扇区相邻则合并为一个请求
		类似电梯保持一个方向移动中间
	最后期限
		一个队列以扇区排序
		同时安排两个按时间排序的读写请求队列，一个请求同时加入3个队列
		没有超时是从普通队列取按linus电梯算法调度，当按时间排序的读写请求队列发生超时则从按时间排序的队列取请求
	预期算法
		当调度了由进程p发出的一个读请求后马上检查排序队列中的下一个请求是否来自进程p.
		if 来自p 则立即调度下一个请求;else 查看进程p的统计信息,如果进程p可能很快发出另一个读请求，那么就延迟一小段时间
	cfq
		每个进程一个队列，每个进程的IO队列有时间片,在进程级别公平
	nop
		不做多少事情，只合并请求，用在没有寻道开销或负担很小的场合,如flash
	
	
	/x
		Linux 文件IO

			fwrite          write         内核线程检测脏页写磁盘，提交到磁盘IO队列  IO调度程序 磁盘控制器
 	应用buffer->C lib buffer->|内核buffer->IO队列  ->驱动|->磁盘设备缓存->磁盘									
								      内核
	x/	
	
设备与模块
	块设备 通过块设备节点的特殊文件访问
	字符设备 通过字符设备节点的特殊文件访问
	网络设备	打破了unix所有东西都是文件的设计原则，不是通过设备节点访问，通过套接字API特殊接口访问
	不是所有设备驱动都表示物理设备，有虚拟设备(such as /dev/null,/dev/zero...)
