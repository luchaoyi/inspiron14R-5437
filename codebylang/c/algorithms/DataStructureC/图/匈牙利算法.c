/*
	这就是匈牙利算法的流程，其中找妹子是个递归的过程，最最关键的字就是“腾”字
	其原则大概是：有机会上，没机会创造机会也要上
*/

#define m ..
#define n ..

//假设数组下标从1开始
girl[m]; //标记m个妹子的男朋友 初始全为0
goodwill[n][m]; //=1表示有好感 关系矩阵
try[m]//此汉子是否试探过此妹子 


int find(x)
{	int i;

/*
	按递归挖墙角思路分析一下：
	x=girl男朋友
	男朋友试图先发治人
	此时try[thisgirl]=1 所以跳过直接找下一个
	然后引起连锁挖墙角大赛(回溯) 自底向上
	大家都有了挖的意向和行动
	直到最后被挖的同学可以找到新妹子他才会放手
	然后空位腾出 自顶向下大家都劈腿了
	 
	3挖2挖1 1找到了放手然后皆大欢喜
	若一找不到 呵呵3 大家都失败

	这个道理告诉我们早找对象不好
	
*/
	for(i=1;i<=m;i++)
	{
		//对所有妹子情况试探
		if(（goodwill[x][i]==1）&&try[i]==0）)
		{	
			try[i]=1;
			
			//没有男朋友或能挖到墙角
			if(girl[m]==0||find(gril[m])) 
			{
				girl[m]=x;
				return true;
			}
		}
			
	}
	return false
}


	
	
	
int main()
{
	/*
		给n位男嘉宾找妹子
	*/
	num=0;//最大匹配
	for(i=1;i<=n;i++)
	{
		memset(try,0,sizeof(try));//初始所有妹子都没有试探过
		if find(i) num++;
		
	}
}
