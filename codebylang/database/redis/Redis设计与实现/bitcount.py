#coding:utf8

#redis bitcount c代码位于bitops.c
#查表法+swar 
#启示
#节省时间则考虑使用空间记忆
#位操作的算法去密码通信找合适算法
#算 时间
#查表 空间

#swar可在常数时间计算32bit的二进制位个数
#O(1)
"""
uint32_t swar(uint32_t i){
        i=(i&0x55555555)+((i>>1)&0x55555555);
        i=(i&0x33333333)+((i>>2)&0x33333333);
        i=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);
        i=(i*(0x01010101)>>24);
        return i;
}
"""
def swar(i):
    i=(i&0x55555555)+((i>>1)&0x55555555)
    i=(i&0x33333333)+((i>>2)&0x33333333)
    i=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F)
    i=(i*(0x01010101)>>24)
    return i

weight_in_byte=[0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8]

def count_bits(bits):
    return len(bits)

def BITCOUNT(bits):
    count=count_bits(bits) #count统计二进制位个数
    weight=0

    #一次处理128bit
    while count>=128:
        weight+=swar(bits[0:32])
        weight+=swar(bits[32:64])
        weight+=swar(bits[64:96])
        weight+=swar(bits[94:128])

       bits=bit[128:]
       count-=128 
    #小于128bit
    #8bit为单位使用查表法
    while count:
        index=unsigned_int(bits[0:8]) #转换为无符号整数，索引table 
        wights+=weight_in_byte[index]
        bits=bits[8:]
        count-=8
        
    return weight 

