/*
 *选择一批数据中前k个最小(大)的算法
 * */


/*
基于快排的算法
如果选定了基准值，一趟循环后基准值的位置为j，j左边的元素都是小于它的，j右边的元素都是大于它的。如果j正好等于k-1，那么数列下标为0到k-1的元素就是最小的k个数，函数返回；如果j小于k-1，那么在j的右边递归的使用快速排序，它会使新的基准值的位置右移，同理j大于k-1时在j的左侧使用快排，让新的基准值位置左移，直到基准值的最终在位置k-1上；
 * */


void Top_k_Qsort(int *a.int left,int right,int k){
	if (left<right)
	{
		int pivot=a[left];
		int i=Left+1,j=Right;
		for(;;){
			while a[i]<pivot{
				++i;
			}

			while a[j]>pivot{
			--j;
			}
			if(i>j)
				break;
			swap(a[i],[j];)

		}
		Swap(a[j],a[Left]); //一次快排过程

		//计算比较j与k的位置
		if(j<k-1)
		{
			Qsort(a,j+1,right,k-1-j); //左边的是top j个,j<k-1不足k个只需要在右边找k-1-j个
		}
		else if(j>k-1)
		{
			Qsort(a,Left,j-1,k);//左边top j个超过了k个，在左边继续进行，寻找k个
		}
		else
			return;
	}


}


/*
数组方法：维护一个大小为K的数组，以数列的前K个数初始化，按照从小到大排列。然后继续从数列中的第K+1个数开始遍历，若小于数组中最大的数，则舍弃这个最大数，更新当前数组，重新排列。插入新的数要遍历这个数组，因此最坏情况时间复杂度为N*K.
改进：
基于堆排序：通过建立一个K个数的堆的方式，最小的K个数利用最大堆（反之求最大的K个数用到最小堆），不断读入数列与堆顶比较。如果小于堆顶表明堆顶不是最小的K个元素之一了，淘汰堆顶并插入
*/

