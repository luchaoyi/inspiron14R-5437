gofmt工具会将你的代码格式化为标准格式,goimports,会自动地添加你代码里需要用到的import声明以及需要移除的import声明。这个工具并没有包含在标准的分发包中
命令行参数可以通过os包中一个叫Args的变量来获取

goroutine是一种函数的并发执行方式,而channel是用来在goroutine之间进行参数传递。main函数也是运行在一个goroutine中,而go function则表示创建一个新的goroutine,
并在这个这个新的goroutine里执行这个函数。

内部预先定义的名字并不是关键字（保留字）,你可以再定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的,但是也要注意避免过度而引起语义混乱
如果一个名字是大写字母开头的，那么它将是导出的,也就是说可以被外部的包访问,例如fmt包的Printf函数就是导出的,可以在fmt包外部访问。包本身的名字一般总是用小写字母。Go语言程序员推荐使用 驼峰式 命名。

Go语言主要有四种类型的声明语句:var、const、type和func,分别对应变量、常量、类型和函数实体对象的声明

	变量
		var 变量名字 类型 = 表达式
		零值初始化机制可以确保每个声明的变量总是有一个良好定义的值,因此在Go语言中不存在未初始化的变量
		在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化
		在函数内部,有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量,变量的类型根据表达式来自动推导。
		“:=”是一个变量声明语句,而“=‘是一个变量赋值操作，i, j = j, i // 交换 i 和 j 的值
	
	指针
		“var x int”声明一个x变量,p:=&x将产生一个指向该整数变量的指针p,指针对应的数据类型是*int,指针被称之为“指向int类型的指针”,*p表达式读取指针指向的变量的值.
		在Go语言中,返回函数中局部变量的地址也是安全的。
		另一个创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变量,初始化为T类型的零值,然后返回变量地址,返回的指针类型为*T.
		对于在包一级声明的变量来说,它们的生命周期和整个程序的运行周期是一致的。而相比之下,在局部变量的声明周期则是动态的:从每次创建一个新变量的声明语句开始,直到该变量不再被引用为止,然后变量的存储空间可能被回收.
		/*局部变量生命周期直到不被引用为止，与c不同，即函数结束，局部变量还有引用则依然存活，因此在Go语言中,返回函数中局部变量的地址也是安全的。
		*/
		因为一个变量的有效周期只取决于是否可达(垃圾回收算法),因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时,局部变量可能在函数返回之后依然存在。
		编译器会自动选择在栈上还是在堆上分配局部变量的存储空间,但可能令人惊讶的是,这个选择并不是由用var还是new声明变量的方式决定的。
		/*不同于C语言局部变量在栈分配，go栈分配局部变量在离开函数时被释放，堆上局部变量由GC管理*/
		
		如果将指向短生命周期对象的指针保存到具有长生命周期的对象中,特别是保存到全局变量时,会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)
		
		
	赋值
		赋值语句右边的所有表达式将会先进行求值,然后再统一更新左边对应变量的值 //x, y = y, x 交换x,y
	
	类型
		变量或表达式的类型定义了对应存储值的属性特征,例如数值在内存的存储大小(或者是元素的bit个数),它们在内部是如何表达的,是否支持一些操作符,以及它们自己关联的方法集等		
		
		type 类型名字 底层类型
			type Celsius float64// 摄氏温度
			type Fahrenheit float64 // 华氏温度
			//Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64,但是它们是不同的数据类型,因此它们不可以被相互比较或混在一个表达式运算,刻意区分类型,可以避免一些像无意中使用不同单位的温度混合计算导致的错误
		一个命名的类型可以提供书写方便,特别是可以避免一遍又一遍地书写复杂类型
		命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合,我们称为类型的方法集 //OOP
		
	包
		import 导入包，导入的是包的路径，此路径下的一个或多个源go代码都是被当作一个包看待。
		
	
Go语言将数据类型分为四类:基础类型、复合类型、引用类型和接口类型
	字符串
		一个字符串是一个不可改变的byte序列,字符串可以包含任意的数据,是通常是用来包含人类可读的文本.
		文本字符串通常被解释为采用UTF8编码的Unicode码点(rune)序列
		子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节(并不包含j本身)生成一个新字符串。生成的新字符串将包含j-i个字节		
		第i个字节并不一定是字符串的第i个字符,因为对于非ASCII字符的UTF8编码会要两个或多个字节
		原生的字符串(反引号代替双引号)字面值中,没有转义操作
		UTF8编码的顺序和Unicode码点的顺序一致,因此可以直接排序UTF8编码序列.
		
	UTF8 and Unicode
		UTF8字符串作为交换格式是非常方便的,但是在程序内部采用rune序列可能更方便,因为rune大小一致,支持数组索引和方便切割.
		string接受到[]rune的类型转换,可以将一个UTF8编码的字符串解码为Unicode字符序列
		如果是将一个[]rune类型的Unicode字符slice或数组转为string,则对它们进行UTF8编码
	常量	
		常量表达式的值在编译期计算,而不是在运行期。每种常量的潜在类型都是基础类型:boolean、string或数字
		常量的运算都可以在编译期完成,这样可以减少运行时的工作,也方便其他编译优化。当操作数是常量时,一些运行时的错误也可以在编译时被发现
		常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，因为它们的值是在编译期就确定的,因此常量可以是构成类型的一部分,例如用于指定数组类型的长度	
	/*-|-|-|-|-*/
	
	数组
		是固定长度的的序列,和数组对应的类型是Slice(切片),它是可以增长和收缩的动态序列。
		在数组字面值中,如果在数组的长度位置出现的是“...”省略号,则表示数组的长度是根据初始化值的个数来计算
			var q [3]int = [3]int{1, 2, 3}
			q := [...]int{1, 2, 3}
		Go语言对待数组的方式和其它很多编程语言不同,其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数，Go语言直接传递一个数组副本。我们可以显式地传入一个数组指针。	
	Slice
		Slice(切片)代表变长的序列,一个slice类型一般写作[]T,slice的语法和数组很像,只是没有固定长度而已。
		slice的底层确实引用一个数组对象，slice由三个部分构成:指针、长度和容量
			指针指向第一个slice元素对应的底层数组元素的地址
			长度对应slice中元素的数目，长度不能超过容量,容量一般是从slice的开始位置到底层数据的结尾位置，内置的len和cap函数分别返回slice的长度和容量。
			多个slice之间可以共享底层的数据,并且引用的数组部分区间可能重叠。
						
			slice的切片操作s[i:j],其中0 ≤ i≤ j≤ cap(s),用于创建一个新的slice,引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素
			切片操作超出cap(s)的上限将导致一个panic异常,但是超出len(s)则是意味着扩展了slice，新slice的长度会变大。

			内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略,在这种情况下,容量将等于长度。在底层,make创建了一个匿名的数组变量,然后返回一个slice;只有通过返回的slice才能引用底层匿名的数组变量。
			slice是数组的引用，底层引用的是数组对象，可变长度的slice的底层是被隐藏的不可变的长度为cap的数组。
			
	Map
		Go语言中,一个map就是一个哈希表的引用,map类型可以写为map[K]V,对应的key必须是支持==比较运算符的数据类型
		map中的元素并不是一个变量,因此我们不能对map的元素进行取址操作，禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间,从而可能导致之前的地址无效。
	结构体
		是一种聚合的数据类型
		如果结构体成员名字是以大写字母开头的,那么该成员就是导出的;这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员
		结构体和数组都是实体，函数调用时是完全复制的，如果考虑效率的话,较大的结构体通常会用指针的方式传入和返回
	

	函数	
		func name(parameter-list) (result-list) {
		body}	
		对于大部分函数而言,永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制，只有没有经验的程序员才会相信读操作不会失败。
		只有没有经验的程序员才会相信读写操作不会失败。
		
		错误处理策略
			最常用的方式是传播错误。这意味着函数中某个子程序的失败,会变成该函数的失败
			如果错误的发生是偶然性的,或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时,我们需要限制重试的时间间隔或重试的次数,防止无限
制的重试
			如果错误发生后,程序无法继续运行,我们就可以采用第三种策略:输出错误信息并结束程序
			只需要输出错误信息就足够了,不需要中断程序的运行
			最后一种策略:我们可以直接忽略掉错误		
		
		函数被看作第一类值(first-class values):函数像其他值一样,拥有类型，函数类型由输入参数个数类型和返回值个数类型决定
			func square(n int) int { return n * n } 类型是func(int) int型
		函数值不仅仅是一串代码,还记录了状态，Go使用闭包(closures)技术实现函数值,Go程序员也把函数值叫做闭包
		
	defer
		直到包含defer语句的函数执行完毕时,defer关键字指定的函数才被执行,不论包含defer语句的函数是通过return正常结束,还是由于panic导致的异常结束。
		你可以在一个函数中执行多条defer语句,它们的执行顺序与声明顺序相反
		defer语句经常被用于处理成对的操作u,如打开、关闭、连接、断开连接、加锁、释放锁。
		通过defer机制,不论函数逻辑多复杂,都能保证在任何执行路径下,资源被释放。释放资源的defer应该直接跟在请求资源的语句后
		
	panic	
		panic异常发生时,程序会中断运行,并立即执行在该goroutine中被延迟的函数(defer 机制),随后,程序崩溃并输出日志信息.
		直接调用内置的panic函数也会引发panic异常.
		通常来说,不应该对panic异常做任何处理,但有时,也许我们可以从异常中恢复,至少我们可以在程序崩溃前,做一些操作
		如果在deferred函数中调用了内置函数recover,并且定义该defer语句的函数发生了panic异常,recover会使程序从panic中恢复,并返回panic value
		你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回,而不是panic。同样的,你也不应该恢复一个由他人开发的函数引起的panic,比如说调用者传入的回调函数,因为你无法确保这样做是安全的.安全的做法是有选择性的recover。换句话说,只恢复应该被恢复的panic异常,此外,这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复,我们可以将panic value设置成特殊类型。在recover时对panic value进行检查,如果发现panic value是特殊类型,就将这个panic作为errror处理,如果不是,则按照正常的panic进行处理
		
	
OOP	
	方法
		func (p Point) Distance(q Point) float64 {return math.Hypot(q.X-p.X, q.Y-p.Y)}
		上面的代码里那个附加的参数p,叫做方法的接收器(receiver),早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息"
		在Go语言中,我们并不会像其它语言那样用this或者self作为接收器;我们可以任意的选择接收器的名字。建议是可以使用其类型的第一个字母,比如这里使用了Point的首字母p.
		当调用一个函数时,会对其每一个参数值进行拷贝。
			如果一个函数需要更新一个变量
			或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了.
		一般会约定如果Point这个类有一个指针作为接收器的方法,那么所有Point的方法都必须有一个指针接收器,即使是那些并不需要这个指针接收器的函数
		只有类型(Point)和指向他们的指针(*Point),才是可能会出现在接收器声明里的两种接收器。此外,为了避免歧义,在声明方法时,如果一个类型名本身是一个指针的话,是不允许其出现在接收器中的.
		一个结构体内嵌另一个结构体扩展自己，则可以使用被嵌入结构体的字段个方法而无需显式指明，(类比c语言gtk，通过结构体内嵌和宏转换实现继承)
		内嵌可以使我们定义字段特别多的复杂类型,我们可以将字段先按小类型分组,然后定义小类型的方法,之后再把它们组合起来。组合小类型构建大类型，对比OOP的自顶向上，组合是自底向上。
		Go语言只有一种控制可见性的手段:大写首字母的标识符会从定义它们的包中被导出,小写字母的则不会(like python)
	
	
	接口
		接口不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合;
		它们只会展示出它们自己的方法。也就是说当你看到一个接口类型的值时,你不知道它是什么,唯一知道的就是可以通过它的方法来做什么
		接口类型具体描述了一系列方法的集合,一个实现了这些方法的具体类型是这个接口类型的实例
		
		/*		
		方法
			接收器实参是类型T,但接收器形参是类型*T,这种情况下编译器会隐式地为我们取变量的地址
			接收器实参是类型*T,形参是类型T。编译器会隐式地为我们解引用,取到指针指向的实际变量
			*T类型接收器拥有T类型所有方法
		*/
		一个类型如果拥有一个接口需要的所有方法,那么这个类型就实现了这个接口
		interface{}被称为空接口类型，因为空接口类型对实现它的类型没有要求,所以我们可以将任意一个值赋给空接口类型。
		接口值由动态类型和动态值构成，类型断言检查它操作对象的动态类型是否和断言的类型匹配
			f, ok := w.(*os.File)// success:ok, f == os.Stdout
			b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil

Goroutines
	go语言中,每一个并发的执行单元叫作一个goroutine。
	一个程序启动时,其主函数即在一个单独的goroutine中运行(main goroutine)。
	go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行

	channels是一个通信机制,它可以让一个goroutine通过它给另一个goroutine发送值信息。
	每个channel都有一个特殊的类型,也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int	
		ch := make(chan int) // ch has type 'chan int'
		channel(like slice/map)是一个对应make创建的底层数据结构的引用.
		一个channel或用于函数参数传递时,只是拷贝了一个channel引用,因此调用者何被调用者将引用同一个channel对象.		
		发送和接收两个操作都是用<-运算符
		基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作.
		类型chan<- int表示只发送int的channel,只能发送不能接收;类型<-chan int表示只接收int的channel,只能接收不能发送.这种限制将在编译期检测	
		带缓存的Channel内部持有一个元素队列,内部缓存队列是满的,那么发送操作才将阻塞.
		
		多路复用select
			select会等待case中有能够执行的case时去执行。当条件满足时,select才会去通信并执行case之后的语句;这时候其它通信是不会执行的。
			一个没有任何case的select语句写作select{},会永远地等待下去。如果多个case同时就绪时,select会随机地选择一个执行,这样来保证每一个channel都有平等的被select的机会。					
	Go语言并没有提供在一个goroutine中终止另一个goroutine的方法,因为会导致goroutine之间的共享变量落在未定义的状态上.
	数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生	
	
	Goroutines 
		可以动态改变栈大小，
		有自己的调度系统，
		没有id标识身份
		
		
		
测试
	先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯.
	
	表格驱动
		将之前的所有测试数据合并到了一个测试中的表格中,这种表格驱动的测试在Go中很常见的. 我们很容易想表格添加新的测试数据, 并且后面的测试逻辑也没
有冗余, 这样我们可以更好地完善错误信息
	随机测试
		构造更广泛的随机输入来测试探索函数的行为

	


	
		
			
		
		

