1:
命令行参数处理
go install jvmgo/ch01
./ch01  -cp /foo/bar MyApp arg1 arg2

2:
类路径，搜索class文件.
	java程序运行需要加载各种class文件,java虚拟机规范没有规定.
	oracle虚拟机根据类路径来搜索类,分为:
	启动类路径:对应jre/lib,java标准库位于该路径,可以通过-Xbootclasspath修改启动类路径
	扩展类路径:jre/lib/ext目录
	用户类路径:可以通过CLASSPATH环境变量指定.一般通过-cp/-classpath指定启动类路径 

java.lang.Object是java类的默认父类
我们的虚拟机通过-Xjre指定启动类路径(所以需要增加一个参数选项).

go install jvmgo/ch02
./ch02 -Xjre /usr/local/lib/java/jdk7/jre java.lang.Object

3.
本章：主要将class文件读入到内存并解析到数据结构中，并定义了使用这些数据的方法。
解析class文件
	每个class文件都代表了一个类，class文件可以从文件读取，从数据库载入，从网络加载。class文件不只是磁盘上的.class文件，而是泛指符合java虚拟机规范要求的class格式的数据(数据可以来自任何可能的来源).
	class文件解析主要是按照格式规定将class文件读取到相应的数据结构中，统计必要的信息.
	class文件以大端方式存储
//go语言访问控制只有公开和私有,大写字母开始为公开，可供其它包访问,小写字母开始为私有，在包内部使用

//属性表携带了一系列属性，用于执行的字节代码，Class文件，字段，方法都有属性用以支持运行,因此都有属性表
Classfile有属性表，字段和方法中也有属性表。
字段和方法属性表描述了方法，字段的属性
而外部的Classfile的属性表，描述符Classfile的属性.
Code属性表是描述执行的字节码属性
4.
java内存区域分两类:
	多线程共享区域:存放类和对象等,主要是堆
	线程私有区域:用于辅助运行字节码,主要是栈.
	
java有两类数据:
	基本类型:存放数据本身
	引用类型:引用存放在栈中(线程私有)，本身数据堆中
	
5.
java的jVM每条指令都以单字节的操作码开始，即操作码占一字节，因此最多有256个操作码,JVM使用的是变长指令.
操作数栈和局部变量表只存储数据值，而不存储数据类型。因此指令需要知道自己操作的数据类型。因此JVM指令针对特定操作类型.
JVM是栈模型机器，操作数在栈中操作，没有寄存器.
指令解码:
	计算pc
	根据pc取操作码，操作数组成指令
	执行指令
	
指令分类:
const指令:指令opcode中隐含常量操作数的
算术运算指令:
	四类:D,F,I,L:double,float,int,long
	七种:+,-,*,/,%,neg(取反)
类型转换指令:用于强制转换类型的指令,出栈->使用go强制转换机制->入栈

6.
运行时常量池：
 主要存放字面量和符号引用
7.
调用的角度方法主要分为
	静态方法:通过类调用，静态绑定.
	实例方法:只能通过对象引用调用，动态绑定.
从JVM实现角度方法分为:
	抽象方法
	java语言方法
	本地方法:用其它语言实现的native方法
8.数组和字符串
数组:
	数组是一个类(非基本类型都是类)，数组由jVM直接生成，不同与普通类，数组对象由newarray指令和anewarray指令创建,multianewarray创建多维数组.
字符串:
	class文件中字符串字面量以MUTF8编码存储.虚拟机运行时，字符串以java.lang.String对象形式存在,String对象内部以utf16存储字符串.
	字符串的java定义如下:
	public final class String
	...
	{
		private final char value[];  //用字符数组存储字符串内容
		private int hash; //字符串hash编码
	}
	
9.
反射:
java的类生成对象，但类是java.lang.Class的对象.类也是对象，称为类对象.
建立类对象和对象的双向关系，即可以通过类对象生成对象，也可此从对象得到类对象.
对象.getClass() \ 对象.class 都可以获得类对象,从而操作类字段，方法等
java的某些基本方法是本地方法，如对象clone,得到对象类名(要解析class文件)。在jvm实现时注册一些本地方法，方便使用.
