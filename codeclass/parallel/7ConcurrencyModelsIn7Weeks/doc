线程和锁
	多线程并发执行，指令序列乱序执行
		编译器静态优化
		JVM动态优化
		硬件乱序
		操作系统调度时间不确定性
	内存可见性
		一个线程修改变量何时对另一个线程可见

	死锁解决
		锁/资源获取的强制顺序性
		获取失败则释放已有资源
		竞争时指数退避

	来自Alien Method(调用的方法，但不了解细节)危害
		Alien Method潜藏bug
		Alien Method是否持有另一把锁?这回打断我们的加锁顺序
		
		避免获取锁时call Alien Method
		保护性复制，将资源复制，对副本进行访问，数据冗余可加快速度

	资源耗尽型攻击
		限制资源申请数量，超过后申请请求将排队,直到有资源释放(申请资源不释放，影响正常使用?)
	
	线程数量选择
		计算密集型，线程数一般选择 cores->2 * cores 
		IO密集型线程，可以设置更多线程 

		避免过度竞争影响效率，可以使用分段锁，和本地副本
	
	阻塞队列
		满或空时阻塞等待，阻塞队列让生产者速度有限超过消费者，不会因为生产速度过大而使队列增长过大耗尽内存


函数式编程
	可变的数据需要加锁保护(良性竞争不用保护)，不变的数据不加锁就可以安全的访问
	函数式编程推崇不可变，确定输入x产生确定的输出f(x)
	命令式编程描述如何求值以得到结果，而函数式编程描述结果应当是怎样的，因此函数式编程对如何安排求值顺序相对自由
	dataflow programming,当函数的数据可用时函数就可执行
	引用透明性
		任何函数调用的地方可以用运行结果代替



原子变量
持久数据结构
代理
引用 

软件事务内存
	A	原子
	C   一致
	I   隔离
	
Actor
CSP(通信顺序进程)
GPU
Lambda架构
	hadoop
	spark
	storm
