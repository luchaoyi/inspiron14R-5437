多核应用编程实战

高性能编码
	1.定义性能
		常用性能指标
			单位时间完成项数，衡量系统完成任务能力
			每项完成时间
	2.了解算法复杂度
		算法复杂度刻画了程序可能占用时间，但没有考虑很多细节。如算法加法与乘法次数，算法cache命中，算法可读性，算法是否容易并行化等
		因此算法复杂度不是选择算法的唯一参考标准.
	3.数据结构对性能影响
			将常常同时访问的变量放入一个结构可使它们驻留在同一cache line
			每次从内存提取数据项，会把相邻的数据代入缓存，适当的数组访问顺序，保证连续性cache命中率高
			选择合适数据结构
	4.编译器作用
		两种编译器基本优化,消除&重组
		选择合适的编译器优化选项
			跨文件优化
			内联
			配置文件反馈优化，编译器先生成一个可执行文件的测试版，然后运行收集运行相关信息，然后在进一步根据这些信息优化算法.
			别名，指向同一个内存位置指针互为别名.指针别名会影响编译器的优化
			
			restrict关键字类型限定符可以告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。使用了关键字restrict，编译器就可以放心地进行优化了
			volatile关键字类型限定符定义的变量，系统每次使用它时都是直接从内存中提取，而不会利用cache当中的原有数值，以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化，因为它的数值随时都可能变化
			
			
	4.性能分析工具
		使用工具分析，性能瓶颈，有目标的优化代码.
				
识别并行机会
	虚拟化技术相互隔离，保证安全，可快速复制,因此虚拟化技术非常适合云计算，虚拟化技术是在最高层次上实现并行机制。
	并行程序是分身术，想象一个同样的你去完成事情.
	数据并行&任务并行,并行化策略
		单个任务拆分为多(进)线程
		多数据单操作，e.g. SIMD多数据单指令
		流水线，划分阶段，流水线执行，流水线各个阶段采用FIFO隔离，流水线各个阶段可以多任务
		客户端-服务器模型，客户端响应外界，将计算请求发送到服务器，服务器响应请求执行计算。
		生产者-消费者模型，类似客户端服务器
		
	通过推测打破依赖，推测，猜对则用，猜错则不用
		执行推测，类似分支预测思想，对分支依赖并行化，提前进行额外的计算，如并行计算两个分支，如果预测成功则使用值，预测失败则丢弃值
		值推测，在执行的同时推测输入值
	关键路径分析
		分析任务的关键执行路径(任务图)，选择无依赖关系的任务并行.		

同步和数据共享
	数据争用，即多个任务数据竞争,可以使用工具检测数据争用
		varlgrind的helgrind可以检测数据争用
		使用锁保证数据just由一个thread访问
	同步原语，同步用于协调多线程活动
		互斥锁，最简单的同步形式，相互排斥，只有a thread can acquire mutex lock,多个线程竞争锁，竞争成功执行，失败则被阻塞.
		自旋锁，自旋锁即，线程会不断尝试获取锁(自旋即一致循环try)而不休眠，短时间的自旋可以及时获取释放的锁，加快执行速度，长时间自旋浪费CPU资源，因此互斥锁可以短时间自旋后休眠
		信号量，可++，--的计数器
		读写锁，允许多读取，不允许写时读，和多写，锁偏向写，当需要写时，获取write lock,获取write lock会阻止继续read lock，待所有读任务释放了自己的read lock后，才可以获取到write lock.
		屏障，阻挡线程，等待所有线程执行到屏障处.
		
		原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）
			如果这个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是一个原子(atomic)操作	
			原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分
			将整个操作视作一个整体是原子性的核心特征
			原子性不可能由软件单独保证,必须需要硬件的支持，因此是和架构相关的
			
			原子操作开销低于同步原语的开销,原子支持的操作是有限的
				CAS,当内存值和预期值匹配时，会互换寄存器和内存中的值	


OpenMP
	嵌套并行,一般先使用sections or tasks提供粗粒度parallel,然后嵌套parallel for 进一步并行
		main->fork|t0->fork|t
			      |t       |t
			      |t       |t
			      |t      
	#pragma omp task,OpenMP3.0引入的新指令
		sections和for，在运行之前，已经可以判断出可以如何去分配任务，而task是“动态”定义任务的，在运行过程中，只要遇到task就创建一个任务，任务被添加到待完成任务列表，然后某一个线程从任务列表取出任务去执行，那么其它的任务就可以并行的执行。
		task可以进行嵌套定义的，可以用于递归的情况等等，task主要适用于不规则的循环迭代（如上面的循环）和递归的函数调用，都是无法使用for来完成的情况。
		
	parallel for collapse(num)子句可以将嵌套循环折叠，num是折叠的循环层数，当最外层并行for迭代次数太少，则可以考虑从折叠
	
		
事物性内存
	事物是一个或者成功或者失败的代码块，失败时不会引起系统任何状态变化。
	事务中使用的变量被另一个线程修改(或可能读取)，则事物将失败,即存在数据争用则事物不可能完成。
	即不加锁，若数据竞争则事物失败.
				
POSIX threads
	app栈大小，pthread_attr_t线程属性设置栈大小，每个线程都有自己的栈，因此每个栈最大栈大小和内存容量决定了线程数上限.
	pthread数据类型 pthread_*_t,*_t
	
	
	锁
		mutex 
		spin mutex
		rwlock
		
	屏障barrier,阻挡线程待所有线程执行到此处
	
	信号量,一个计数值
		sem_wait(),将值-1,或已经为0则线程等待 P
		sem_post(),将值+1   V
		PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用P,V操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。
		信号量S>=0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S<0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去
	
	条件变量,交流状态变化
	


变量和内存
	线程会共享全局变量，和堆内存，线程栈是私有的
	线程本地存储，某变量A是全局的对所有线程可见，但每一个线程都有A的一个私有副本
		
UNIX多进程模型,fork-exec
	fork调用，子进程和父进程都从它返回，父进程中得到一个子进程的pid，子进程返回0,即pid is 0,则是在子进程中,fork创建的子进程是父进程副本
	exec调用指定子进程操作，它会将sub process 的空间覆盖替换
	
	IPC
		共享内存,shm_open()创建一个共享内存段,使用mmap()连接到内存段,使用munmap()取消映射,使用shm_unlink()remove 共享内存段.使用共享内存可存放进程间共享互斥量.
		信号量,PV操作
			  
		消息队列,mq_open创建或连接到消息队列，mq_close关闭连接，mq_unlink删除消息队列.在消息队列属性中设置消息队列最大存储消息条数和消息长度.消息队列发送消息需要两次复制,buffer->q,q->buffer,因此短消息有优势，长消息使用mmap.
		
		管道
			pipe,创建匿名管道，返回两端文件描述符(such as A,B,A and B is file descriptor),使用B端读取内容，使用A端写入内容。
			mknod,创建命名管道，然后可以像使用文件一样使用它.
			
		信号,in类unix os,可以向app send signal,and app can set signal process program 对 signal拦截处理.
			signal()安装信号处程序
			kill() 向指定的pid进程发送信号
			sigaction()可以在信号已有的处理程序前添加一个新的处理程序，调用后将已有的处理程序保存在一个结构中，先调用新程序，新程序接受旧程序结构为参数，新程序在执行在完成自己的处理动作后,需要在末尾调用旧的处理程序.so 形成了一个handle link
				
		socket
			协议族AF_INET,AF_INET6 is IPV4,IPV6
			传输层协议类型
				SOCK_STREAM TCP 面向连接的、可靠的、基于字节流的传输层通信协议
				SOCK_DGRAM UDP 用户数据报协议
			server:socket bind listen accept
			client:socket connect
	
可重入函数
	若一个程序或子程序可以安全的被并行执行，则称其为可重入.若一个函数是可重入的，则该函数:不能含有静态（全局）非常量数据。 不能返回静态（全局）非常量数据的地址。 只能处理由调用者提供的数据。 不能依赖于单实例模式资源的锁。 不能调用不可重入的函数。 多'用户/对象/进程优先级'以及多进程一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的资源.
	使用可重入函数，保证并行安全性
	
	
	

无锁算法

	使用原子操作代替锁
	原子操作，成功or失败，不存在部分状态或操作成功结果不正确
		x86 指令前缀lock操作，lock操作锁住系统总线,使其它处理器不能访问正在更新的位置，lock使指令成为原子操作
		多数处理器实现了CAS操作
			e.g. CAS(&lock,0,1) 
				if lock==0,then 
					lock=1,操作成功，返回0;
				else
					不更新lock,操作失败,返回其它值;
	
		尽量使用操作系统提供的原子操作,e.g. gcc 原子操作函数
			__sync_fetch_and_add()
			__sync_fetch_and_or()
			__sync_fetch_and_xor()
			__sync_fetch_and_and()
			__sync_val_compare_and_swap() CAS
			__sync_fetch_and_...()
		使用原子操作比互斥锁保护变量开销更小
		
	设计无需锁的算法，需要考虑数据状态和状态转换，实现非常复杂.e.g.
		

线程迁移
	指一个线程最初在一个虚拟CPU上执行，但后来迁移到不同的虚拟处理器上.如果old cpu and new cpu 共享同一core and cache,则迁移成本低.但如果从一个hardware core 迁移到 other core，则成本比较高.
	numactl可以查询硬件拓扑结构，且让用户指定运行应用程序的虚拟处理器
	可以在程序中绑定线程到虚拟CPU以避免线程迁移，控制线程运行位置是不可移植的
	
		

/*
C语言关键字
	restrict关键字类型限定符可以告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。使用了关键字restrict，编译器就可以放心地进行优化了
	volatile关键字类型限定符定义的变量，系统每次使用它时都是直接从内存中提取，而不会利用cache当中的原有数值，以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化，因为它的数值随时都可能变化
*/








	
	
	
