/*
 *基数排序
 *
 *
 *使用快排划分的基数排序
 *当每位只有取值0/1时，可以从高位到低位，使用快排思想排序
 * 0010 0100 1011 0110 1001
 *				i<->j		
 *划分: 第一位为0  | 第一位为1 
 0010 0100 0110| 1011 1001 
 ...


 *
 * 直接基数排序,从低位到高位分箱(初始感觉它似乎是违反直觉的，数字比较时是从高位到低位比较的)
 * 分箱高位在后面是应为越后面越起到决定性作用
 * 即后面可以打破前面的规则.则后面的优先级别高，因此是从低位到高位
 *
 * 12 23 34 45  56 31
 *  
 *  1:31    12 
 *  2:12    23
 *	3:23    31 34  
 *	4:34 -> 45 
 *	5:45    56       
 *	6:56
 *
 *	基数排序若不使用多个桶只在一个数组上进行，则需要进行统计和前缀求和，计算出每个元素分布段
 *
 * 12 23 34 45  56 31 
 *     
 * count	  0|0 1  1 1 1  1 1 0 0 0   
 * scancount   |0 0  1 2 3  4 5 6 6 6          
 * index	   |0 1  2 3 4  5 6 7 8 9 
 *
 * 12:基数2   
 * scancount[2]=1,代表前面基数为0和为1的数只有1个则 
 * A[scancount[2]++]=12
 * A              12
 * index	   |0 1  2 3 4  5 6 7 8 9 
 *
 * 通过统计来安排不同基数在数组中的位置,保证在一个数组中按基数排列
 * */

/*step1:统计数量count 可并行，可分块统计
 *step2:前缀求和scan  可并行，前缀求和并行算法
 *step3:写入数组     基数为0|基数为1|基数为2 |...
 写入同一个基数区间的可并行循环，但不能不同线程处理不同区间的这样，上次基数排序的顺序就会混乱
 *
 * */
/*
 *个人感觉使用桶和数组更速度更快，以空间换时间
 * */
