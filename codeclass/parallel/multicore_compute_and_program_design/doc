多核计算与程序设计|周

lock是os同步原语
线程间同步锁,同一时刻只能由一个thread持有，不能被同时持有
锁的特性:
	互斥锁,若有进程持有锁，则未释放锁之前其它访问锁的进程会被阻塞
	旋转锁,若等待锁时不立即进入睡眠状态，而是不断循环尝试，直到获取到锁.旋转锁不适合单核CPU，单核下不断尝试是浪费资源。旋转锁一般也应该设置一个旋转次数
	递归锁,同一个线程没有释放锁，就能多次重复获取锁，同一thread内释放与获取次数应该一致，否则其它线程无法获取this锁.
	读写锁，多读单写特性,允许多个同时读，但只允许一个写.访问非共享变量和读时不保护，写时才保护.
	分布式锁,对于大数据块，锁竞争激烈，锁操作频繁的考虑分治，使用划分分布式锁，加快速度.

原子操作,不可分割的操作.原子操作比锁的执行速度更快，但是编程复杂度更高.

有锁计算,使用锁来保护，以避免数据竞争.
无锁计算,不使用锁，使用原子操作，速度更快.
本地计算,将数据合理划分为线程私有，不存在数据竞争.

线程退出,若主线程退出时，释放了资源，没有杀死子线程之前，发生线程切换此时子线程访问已释放资源会发生错误.因此主线程退出时需要通知子线程，并等待使子线程退出后在释放资源。

--------------------
OpenMP:是将原始os线程接口进行适配以使其拥有更易于被数值软件采用的层次(封装原始接口,更易使用)
	变量:
	并行块外部声明的变量默认是共享变量.
	并行块内声明的变量默认是每个线程私有的局部变量，不被共享.

	private:声明线程私有变量，即使并行区域外有同名共享变量,区域外共享变量不起任何作用，也不会操作到外面的共享变量.
	firstprivate:创建私有变量时会继承共享变量的值,即相当于对共享变量拷贝了私有副本.
	lastprivate:退出并行区域时，将私有变量值，赋值给区域外的同名共享变量.
	threadprivate:只能用于声明全局变量或静态变量,并且变量使用有一定的限制.
	shared:用于声明变量是共享的.



	openMP是一个编译器指令和库函数集合.
	openMP使用Fork/Join，主线程执行串行部分，并行部分Fork子线程执行，主线程Join直到子线程执行完,才可以继续执行.
	openMP访问的变量有共享和私有两种方式.
		并行区域外的变量，在并行区域内使用时，各个线程访问的是引用，因此是共享变量。
		并行区域内的变量，各个线程会创建自己的私有拷贝。
	openMP编译指导语句:命令+子句列表
	openMP还包含一部分库函数.(包含获得线程数，处理器个数，锁操作)线程数设置原则
		1.每个线程运行循环次数不小于a(e.g. a=4)次，不能粒度太小
		2.总的运行线程数最大不超过b(e.g. b=2)倍CPU核数
		3.一般线程数=CPU核数性能较好，没有切换开销

	
	任务调度,每个线程的计算量应该均衡，否则会影响性能.
	schedule(type,size)
		type:
			static 默认方式，没有schedule时使用static
			dynamic 
			guided 启发式调度
			runtime 根据OMP_SCHEDULE  env var 确定调度类型，如setenv OMP_SCHEDULE "dynamic,2"

	线程同步,
	#pragma omp critical ，临界区被被翻译为加锁解锁操作.
	#pragma omp atomic ，临界区被翻译为原子操作，原子操作快于锁操作，因此尽量使用atomic代替critical.
	#pragma omp flush ,使线程临时内存视图与实际内存保持一致.
	
		
	伪共享问题:
		多个线程写同一Cache行，就产生了伪共享问题.两个线程同时写相邻内存可能相邻内存位于一个Cache行中，就可能造成伪共享问题
		没有真正的访问共享存储空间，却因为Cache行特性而竞争。
		数组补全技术，即不同线程更新内存位置插入合适的空间，使每个线程独占一个cache行，测可以避免Cache行伪共享.


并行分解任务时应考虑负载均衡，各个线程时间差异不能太大.
并行计算设计思路:
	1.数据分解，
	2.计算分解
	3.分治法
	

模式:
	1.数据分解模式
	2.分治模式(问题分解)
	3.流水线模式
	4.任务图模式，任务存在依赖关系时采用任务图描述任务分配，根据任务图调度
	5.动态调度，任务动态产生时的调度
		全局共享队列,维护一个global任务队列，任务线程从队列读取任务，会发生集中式锁竞争.
		任务偷取，每个任务维护自己的队列，当自己任务队列无任务时，随机从其它队列取任务.

并行程序设计:
	1.应考虑若CPU核数增加，算法是否能不修该而获得线性加速比.
	2.资源频繁的释放，申请会增加开销，可以使用池化技术.
	3.控制线程粒度，频繁创建线程会增加额外开销.
		将任务平摊到各个核上的调度策略，如果核数多，任务少的情况下，线程粒度会过小.

	
避免锁竞争式使线程空闲，负载不均.
	1.线程分组竞争，将线程分组，同一组线程竞争一个锁，不同组线程无竞争.
	2.线程随机竞争，多个线程随机竞争某个子资源，竞争概率相等.
	3.条件同步，满足一定条件才同步.
	4.批量私有化，将小批量数据访问改成大量批数据访问，减少lock,unlock.
	5.本地计算（不加锁计算），将数据合理划分为线程私有，不存在数据竞争.
	
多级分布式数据结构可以将锁竞争划分到不同级别 and 同一级别的不同部分，减少了竞争冲突.	


内存管理
	等尺寸内存管理
		将一块大的内存分解为多个相同尺寸的小块内存.让空闲小块连成一个链表.初始化时也可以不连接链表。而是FreeList->NULL,当释放内存时将其放入FreeList.当连续内存块分配完后，从FreeList分配内存.
	
	抢占式内存管理算法
		管理线程私有内存不需要锁，因为私有无竞争。共享内存的访问需要加锁，但是任一块内存的分配和释放不需要锁，因为某块内存的malloc必在其free之前发生，一块内存不可能同时发生free和malloc,而对此块内存的free和malloc只有唯一线程进行。
		
	Intel TBB 内存管理
		Cache行对齐算法
			多个线程读取同一个Cache行引起竞争，使用Cache行对齐来使各块不同的内存位于不同的Cache行内.
			e.g.
				Cache 64B对齐的，假设k为任一正整数，内存地址k*64->(k+1)*64-1的内存块位于同一个Cache行里.
		抢夺式内存管理算法	
			每个线程都有一个私有FreeList，线程从自己的FreeList申请内存，用完后归还到FreeList中。即线程自己管理分配和释放，并且设置阈值，若某个线程额FreeList太多则将多余的块放入空闲内存池中，供FreeList不足的线程申请.
			线程释放内存时，如果FreeList已经满足，则放入线程池
			线程申请内存时，如果FreeList已经不足，则从线程池取
				
lock-free
	独占锁：是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。
	乐观锁：每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。
	乐观锁用到的机制就是CAS，Compare and Swap。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
	
	使用CAS原子操作代替锁操作。
	CAS原子操作代码描述如下:
   1: int compare_and_swap(int* reg, int oldval, int newval)
   2: {
   3:   ATOMIC();
   4:   int old_reg_val = *reg;
   5:   if (old_reg_val == oldval)
   6:      *reg = newval;
   7:   END_ATOMIC();
   8:   return old_reg_val;
   9: }
   即检查内存*reg里的值是不是oldval，如果是的话，则对其赋值newval。上面的代码总是返回old_reg_value，调用者如果需要知道是否更新成功还需要做进一步判断，为了方便，它可以变种为直接返回是否更新成功，如下：
   1: bool compare_and_swap (int *accum, int *dest, int newval)
   2: {
   3:   if ( *accum == *dest ) {
   4:       *dest = newval;
   5:       return true;
   6:   }
   7:   return false;
   8: }
   	
	引入问题
		ABA:
			CAS修改指针变量时引入了ABA问题,通过修改指针时计数方法解决，每次对指针修改，对该指针计数加1，CAS比较时同时比较指针值和计数值。
		内存删除：
			一个线程对某块内存已经释放，但其它线程还需要访问。
			可以使用垃圾内存回收机制，使用完后线程并不释放内存，而是由gc在没有任何指针指向此内存时，进行垃圾回收.
			没有垃圾回收机制的环境下，lock-free会产生数据竞争，合适的解决办法还是用户层去实现一个简易内存垃圾回收.
		


-------------------------------------------------
<intel|多核程序设计|李宝峰译>
intel为VMM开发了指令集，以更好的支持虚拟化技术


同步原子操作(同步原语)
	信号量用一个整数sem表示,有P和V原子操作
		#申请一个资源没有则阻塞，等待被唤醒
		p(s):
			原子操作{sem=sem-1;temp=sem} 
				if(temp<0){
					调用线程被阻塞并插入到信号量s的等待队列
				}
	
		#释放一个资源，若有因为没有申请到资源被阻塞的进程，则唤醒一个
		v(s):
			原子操作{sem=sem+1;temp=sem}
			if(temp<=0){
				唤醒一个被阻塞的进程
			}

	锁,用于acquire和release原子操作
		mutex lock,使用try finally可避免死锁
		递归lock,获取和释放成对操作，其它线程才可获得锁
		读写lock,多读单写
		spin lock,旋转等待，不阻塞，若等待时间少于阻塞唤醒线程切换开销则使用spin lock

	条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使"条件成立"（给出条件成立信号。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起
		wait():原子操作，释放自身持有的锁并等待
		signal():唤醒一个等待线程,被唤醒线程会申请在wait时释放的锁，仍然持有锁
		broadcast():唤醒等待所有线程,执行完此操作，仍然持有锁



并行设计常见问题
	线程数不宜太多一般2倍物理核心最佳(每个物理核使用超线程可运行两个线程)
	将计算线程和IO线程分离
	无锁ABA问题,为指针添加一个标号



		
	
	
